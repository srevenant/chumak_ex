# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:52

defmodule :chumak_curve_if do
  @defined_CHUMAK_CURVE_LIB_ENACL System.get_env("DEFINE_CHUMAK_CURVE_LIB_ENACL") != nil

  @defined_CHUMAK_CURVE_LIB_NACERL System.get_env("DEFINE_CHUMAK_CURVE_LIB_NACERL") != nil

  @defined_CHUMAK_CURVE_LIB_NACL System.get_env("DEFINE_CHUMAK_CURVE_LIB_NACL") != nil

  @defined_CHUMAK_CURVE_LIB_NONE System.get_env("DEFINE_CHUMAK_CURVE_LIB_NONE") != nil

  defmacrop erlmacro(name, args) when is_atom(name),
    do: {Module.get_attribute(__MODULE__, name), [], args}

  defmacrop erlmacro(macro, args), do: {Macro.expand(macro, __CALLER__), [], args}

  if @defined_CHUMAK_CURVE_LIB_NACERL do
    defmacrop erlconst_CURVE_MOD() do
      quote do
        :nacerl
      end
    end

    @defined_CURVE_MOD true
    @erlconst_CURVE_MOD :erlconst_CURVE_MOD
  end

  if @defined_CHUMAK_CURVE_LIB_NACL do
    defmacrop erlconst2_CURVE_MOD() do
      quote do
        :nacl
      end
    end

    @defined_CURVE_MOD true
    @erlconst_CURVE_MOD :erlconst2_CURVE_MOD
  end

  if @defined_CHUMAK_CURVE_LIB_ENACL do
    defmacrop erlconst3_CURVE_MOD() do
      quote do
        :enacl
      end
    end

    @defined_CURVE_MOD true
    @erlconst_CURVE_MOD :erlconst3_CURVE_MOD
  end

  if @defined_CHUMAK_CURVE_LIB_NONE do
    defmacrop erlconst4_CURVE_MOD() do
      quote do
        :none
      end
    end

    @defined_CURVE_MOD true
    @erlconst_CURVE_MOD :erlconst4_CURVE_MOD
  end

  if not @defined_CURVE_MOD do
    defmacrop erlconst5_CURVE_MOD() do
      quote do
        :none
      end
    end

    @defined_CURVE_MOD true
    @erlconst_CURVE_MOD :erlconst5_CURVE_MOD
  end

  @spec randombytes(integer()) :: binary()

  def randombytes(size) do
    case(erlmacro(:erlconst_CURVE_MOD, [])) do
      :none ->
        throw(:not_supported)

      _ ->
        erlmacro(:erlconst_CURVE_MOD, []).randombytes(size)
    end
  end

  @spec box_keypair() :: %{secret: binary(), public: binary()}

  def box_keypair() do
    case(erlmacro(:erlconst_CURVE_MOD, [])) do
      :none ->
        throw(:not_supported)

      :nacl ->
        {:nacl_box_keypair, pk, sk} = :nacl.box_keypair()
        %{secret: sk, public: pk}

      _ ->
        erlmacro(:erlconst_CURVE_MOD, []).box_keypair()
    end
  end

  @spec box(binary(), binary(), binary(), binary()) :: binary()

  def box(message, nonce, publicKey, secretKey) do
    case(erlmacro(:erlconst_CURVE_MOD, [])) do
      :none ->
        throw(:not_supported)

      :nacl ->
        {:nacl_envelope, _, binary} = :nacl.box(message, nonce, publicKey, secretKey)
        binary

      _ ->
        erlmacro(:erlconst_CURVE_MOD, []).box(message, nonce, publicKey, secretKey)
    end
  end

  @spec box_open(binary(), binary(), binary(), binary()) :: {:ok, binary()}

  def box_open(var_box, nonce, publicKey, secretKey) do
    case(erlmacro(:erlconst_CURVE_MOD, [])) do
      :none ->
        throw(:not_supported)

      _ ->
        erlmacro(:erlconst_CURVE_MOD, []).box_open(var_box, nonce, publicKey, secretKey)
    end
  end
end
