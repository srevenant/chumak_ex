# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:55

defmodule :chumak_pub do
  require Record

  @behaviour :chumak_pattern

  @erlrecordfields_chumak_pub [:identity, :subscriptions, :xpub, :recv_queue, :pending_recv]
  Record.defrecordp(:erlrecord_chumak_pub, :chumak_pub,
    identity: :undefined,
    subscriptions: :undefined,
    xpub: false,
    recv_queue: nil,
    pending_recv: nil
  )

  def valid_peer_type(:sub) do
    :valid
  end

  def valid_peer_type(:xsub) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    init(var_identity, [])
  end

  def init(var_identity, opts) do
    state =
      erlrecord_chumak_pub(identity: var_identity, subscriptions: :chumak_subscriptions.new())

    {:ok, apply_opts(state, opts)}
  end

  def terminate(_reason, erlrecord_chumak_pub(pending_recv: var_recv)) do
    case(var_recv) do
      {:from, from} ->
        :gen_server.reply(from, {:error, :closed})

      _ ->
        :ok
    end

    :ok
  end

  def identity(erlrecord_chumak_pub(identity: i)) do
    i
  end

  defp apply_opts(state, []) do
    state
  end

  defp apply_opts(state, [:xpub | opts]) do
    apply_opts(erlrecord_chumak_pub(state, xpub: true, recv_queue: {:some, :queue.new()}), opts)
  end

  def peer_flags(erlrecord_chumak_pub(xpub: true)) do
    {:xpub, [:incoming_queue]}
  end

  def peer_flags(_state) do
    {:pub, [:pub_compatible_layer]}
  end

  def accept_peer(state, peerPid) do
    {:reply, {:ok, peerPid}, state}
  end

  def peer_ready(state, _peerPid, _identity) do
    {:noreply, state}
  end

  def send(state, data, from) do
    send_multipart(state, [data], from)
  end

  def recv(erlrecord_chumak_pub(xpub: true) = state, _from) do
    {:reply, {:error, :not_implemented_yet}, state}
  end

  def recv(state, _from) do
    {:reply, {:error, :not_use}, state}
  end

  def send_multipart(erlrecord_chumak_pub(subscriptions: subscriptions) = state, multipart, _from) do
    [firstPart | _] = multipart
    peersPids = :chumak_subscriptions.match(subscriptions, firstPart)
    :lists.foreach(fn peerPid -> :chumak_peer.send(peerPid, multipart) end, peersPids)
    {:reply, :ok, state}
  end

  def recv_multipart(
        erlrecord_chumak_pub(pending_recv: nil, xpub: true, recv_queue: {:some, recvQueue}) =
          state,
        from
      ) do
    case(:queue.out(recvQueue)) do
      {{:value, multipart}, newRecvQueue} ->
        {:reply, {:ok, multipart}, erlrecord_chumak_pub(state, recv_queue: {:some, newRecvQueue})}

      {:empty, _recvQueue} ->
        {:noreply, erlrecord_chumak_pub(state, pending_recv: {:from, from})}
    end
  end

  def recv_multipart(erlrecord_chumak_pub(xpub: true) = state, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :not_use}, state}
  end

  def unblock(erlrecord_chumak_pub(pending_recv: {:from, pendingRecv}) = state, _from) do
    newState = erlrecord_chumak_pub(state, pending_recv: nil)
    :gen_server.reply(pendingRecv, {:error, :again})
    {:reply, :ok, newState}
  end

  def unblock(erlrecord_chumak_pub(pending_recv: nil) = state, _from) do
    {:reply, :ok, state}
  end

  def peer_recv_message(state, _message, _from) do
    {:noreply, state}
  end

  def queue_ready(erlrecord_chumak_pub(xpub: true) = state, _identity, peerPid) do
    case(:chumak_peer.incoming_queue_out(peerPid)) do
      {:out, multipart} ->
        {:noreply, handle_queue_ready(state, multipart)}

      :empty ->
        {:noreply, state}

      {:error, info} ->
        :error_logger.info_msg('can\'t get message out in ~p with reason: ~p~n', [
          :chumak_pub,
          info
        ])

        {:noreply, state}
    end
  end

  def queue_ready(state, _identity, _peerPid) do
    {:noreply, state}
  end

  def peer_disconected(erlrecord_chumak_pub(subscriptions: subscriptions) = state, peerPid) do
    newSubscriptions = :chumak_subscriptions.delete(subscriptions, peerPid)
    {:noreply, erlrecord_chumak_pub(state, subscriptions: newSubscriptions)}
  end

  def peer_subscribe(
        erlrecord_chumak_pub(subscriptions: subscriptions) = state,
        peerPid,
        subscription
      ) do
    newSubscriptions = :chumak_subscriptions.put(subscriptions, peerPid, subscription)
    {:noreply, erlrecord_chumak_pub(state, subscriptions: newSubscriptions)}
  end

  def peer_cancel_subscribe(
        erlrecord_chumak_pub(subscriptions: subscriptions) = state,
        peerPid,
        subscription
      ) do
    newSubscriptions = :chumak_subscriptions.delete(subscriptions, peerPid, subscription)
    {:noreply, erlrecord_chumak_pub(state, subscriptions: newSubscriptions)}
  end

  defp handle_queue_ready(
         erlrecord_chumak_pub(xpub: true, pending_recv: nil, recv_queue: {:some, recvQueue}) =
           state,
         data
       ) do
    newRecvQueue = :queue.in(data, recvQueue)
    erlrecord_chumak_pub(state, recv_queue: {:some, newRecvQueue})
  end

  defp handle_queue_ready(
         erlrecord_chumak_pub(xpub: true, pending_recv: {:from, pendingRecv}) = state,
         data
       ) do
    :gen_server.reply(pendingRecv, {:ok, data})
    erlrecord_chumak_pub(state, pending_recv: nil)
  end
end
