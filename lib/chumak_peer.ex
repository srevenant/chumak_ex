# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:55

defmodule :chumak_peer do
  require Record

  # Begin included file: chumak.hrl

  @type transport() :: :tcp

  @type socket_type() ::
          :req | :rep | :dealer | :router | :pub | :xpub | :sub | :xsub | :push | :pull | :pair

  @typep z85_key() :: char_list()

  @typep socket_option() ::
           :curve_server
           | :curve_publickey
           | :curve_secretkey
           | :curve_serverkey
           | :curve_clientkeys

  @typep security_mechanism() :: :null | :curve

  defmacrop erlmacro_SOCKET_OPTS(opts) do
    quote do
      :lists.append([:binary, {:active, false}, {:reuseaddr, true}], unquote(opts))
    end
  end

  defmacrop erlconst_GREETINGS_TIMEOUT() do
    quote do
      1000
    end
  end

  defmacrop erlconst_RECONNECT_TIMEOUT() do
    quote do
      2000
    end
  end

  # End included file: chumak.hrl

  @behaviour :gen_server

  @typep peer_step() :: :waiting_peer | :waiting_ready | :ready

  @typep peer_opts() :: list(peer_opt())

  @typep peer_opt() ::
           :incoming_queue
           | :multi_socket_type
           | {:curve_server, boolean()}
           | {:curve_publickey, binary()}
           | {:curve_secretkey, binary()}
           | {:curve_serverkey, binary()}

  @typep handshake_data() :: {:error, term()} | {:ready, map()}

  @erlrecordfields_state [
    :step,
    :host,
    :port,
    :conn_side,
    :resource,
    :type,
    :identity,
    :peer_identity,
    :peer_version,
    :socket,
    :decoder,
    :parent_pid,
    :incoming_queue,
    :msg_buf,
    :pub_compatible_layer,
    :multi_socket_type,
    :as_server,
    :mechanism,
    :security_data
  ]
  Record.defrecordp(:erlrecord_state, :state,
    step: :waiting_ready,
    host: :undefined,
    port: :undefined,
    conn_side: :undefined,
    resource: [],
    type: :undefined,
    identity: [],
    peer_identity: [],
    peer_version: nil,
    socket: nil,
    decoder: nil,
    parent_pid: :undefined,
    incoming_queue: nil,
    msg_buf: [],
    pub_compatible_layer: false,
    multi_socket_type: false,
    as_server: false,
    mechanism: :null,
    security_data: %{}
  )

  @typep state() ::
           record(:erlrecord_state,
             step: peer_step(),
             host: :undefined | nil | char_list(),
             port: :undefined | nil | number(),
             conn_side: :undefined | :server | :client,
             resource: char_list(),
             type: :undefined | socket_type(),
             identity: char_list(),
             peer_identity: char_list(),
             peer_version: nil | {number(), number()},
             socket: nil | :gen_tcp.socket(),
             decoder: nil | :chumak_protocol.decoder(),
             parent_pid: :undefined | pid(),
             incoming_queue: nil | :queue.queue(),
             msg_buf: list(),
             pub_compatible_layer: false | true,
             multi_socket_type: false | true,
             as_server: boolean(),
             mechanism: security_mechanism(),
             security_data: :chumak_curve.curve_data() | %{}
           )

  @spec connect(socket_type(), transport(), list(), integer(), term(), peer_opts()) ::
          {:ok, pid()} | {:error, term()}

  def connect(type, :tcp, host, port, resource, opts)
      when is_atom(type) and is_list(host) and is_integer(port) and is_list(resource) do
    :gen_server.start_link(__MODULE__, {:connect, type, host, port, resource, opts, self()}, [])
  end

  def connect(type, protocol, host, port) do
    connect(type, protocol, host, port, [])
  end

  def connect(type, protocol, host, port, resource) do
    connect(type, protocol, host, port, resource, [])
  end

  @spec accept(socket_type() | :none, pid(), peer_opts()) :: {:ok, pid()} | {:error, term()}

  def accept(type, socket, opts) do
    :gen_server.start_link(__MODULE__, {:accept, type, socket, opts, self()}, [])
  end

  def accept(type, socket) do
    accept(type, socket, [])
  end

  @spec send(pid(), list(binary()), term()) :: :ok

  def send(peerPid, data, client) do
    :gen_server.cast(peerPid, {:send, data, client})
  end

  def send(peerPid, data) do
    :gen_server.cast(peerPid, {:send, data})
  end

  def send_subscription(peerPid, subscription) do
    :gen_server.cast(peerPid, {:send_subscription, subscription})
  end

  def send_cancel_subscription(peerPid, subscription) do
    :gen_server.cast(peerPid, {:send_cancel_subscription, subscription})
  end

  @spec incoming_queue_out(pid()) :: {:out, list()} | :empty | {:error, _} when _: any()

  def incoming_queue_out(peerPid) do
    try do
      :gen_server.call(peerPid, :incoming_queue_out)
    catch
      _error, info ->
        {:error, info}
    end
  end

  def reconnect(peerPid) do
    :gen_server.cast(peerPid, :reconnect)
  end

  def send_error(peerPid, reasonMsg) do
    :gen_server.cast(peerPid, {:send_error, reasonMsg})
  end

  def close(peerPid) do
    :gen_server.stop(peerPid)
  end

  def init({:connect, type, host, port, resource, opts, parentPid}) do
    :gen_server.cast(self(), :connect)
    state = pending_connect_state(type, host, port, resource, opts, parentPid)
    {:ok, state}
  end

  def init({:accept, type, socketPid, opts, parentPid}) do
    {:ok, accepted_state(type, socketPid, opts, parentPid)}
  end

  def code_change(_oldVsn, state, _extra) do
    {:ok, state}
  end

  def handle_call(:incoming_queue_out, _from, erlrecord_state(incoming_queue: nil) = state) do
    :error_logger.error_report([:incoming_queue_out, {:error, :incoming_queue_not_enabled}])
    {:reply, {:error, :incoming_queue_not_enabled}, state}
  end

  def handle_call(
        :incoming_queue_out,
        _from,
        erlrecord_state(incoming_queue: incomingQueue) = state
      ) do
    case(:queue.out(incomingQueue)) do
      {{:value, messages}, newQueue} ->
        {:reply, {:out, messages}, erlrecord_state(state, incoming_queue: newQueue)}

      {:empty, _incomingQueue} ->
        {:reply, :empty, state}
    end
  end

  def handle_cast(
        {:send, multipart, client},
        erlrecord_state(
          socket: socket,
          mechanism: mechanism,
          security_data: security_data,
          step: :ready
        ) = state
      ) do
    {data, newSecurityData} =
      :chumak_protocol.encode_message_multipart(multipart, mechanism, security_data)

    case(:gen_tcp.send(socket, data)) do
      :ok ->
        :gen_server.reply(client, :ok)

      {:error, reason} ->
        :gen_server.reply(client, {:error, reason})
    end

    {:noreply, erlrecord_state(state, security_data: newSecurityData)}
  end

  def handle_cast(
        {:send, multipart},
        erlrecord_state(mechanism: mechanism, security_data: securityData, step: :ready) = state
      ) do
    {data, newSecurityData} =
      :chumak_protocol.encode_message_multipart(multipart, mechanism, securityData)

    send_data(data, erlrecord_state(state, security_data: newSecurityData))
  end

  def handle_cast({:send_error, reasonMsg}, erlrecord_state(socket: socket) = state) do
    send_error_to_socket(socket, reasonMsg)
    {:noreply, state}
  end

  def handle_cast({:send_subscription, topic}, erlrecord_state(peer_version: {3, 0}) = state) do
    frame = :chumak_protocol.encode_old_subscribe(topic)
    send_data(frame, state)
  end

  def handle_cast({:send_subscription, topic}, state) do
    command = :chumak_command.encode_subscribe(topic)
    frame = :chumak_protocol.encode_command(command)
    send_data(frame, state)
  end

  def handle_cast(
        {:send_cancel_subscription, topic},
        erlrecord_state(peer_version: {3, 0}) = state
      ) do
    frame = :chumak_protocol.encode_old_cancel(topic)
    send_data(frame, state)
  end

  def handle_cast({:send_cancel_subscription, topic}, state) do
    command = :chumak_command.encode_cancel(topic)
    frame = :chumak_protocol.encode_command(command)
    send_data(frame, state)
  end

  def handle_cast(:connect, state) do
    try_connect(state)
  end

  def handle_cast(:negotiate_greetings, state) do
    negotiate_greetings(state)
  end

  def handle_cast(:reconnect, erlrecord_state(socket: socket) = state) do
    :gen_tcp.close(socket)
    try_connect(state)
  end

  def handle_info({:tcp, _port, frame}, state) do
    :ok = :inet.setopts(erlrecord_state(state, :socket), active: :once)
    reply = :chumak_protocol.decode(erlrecord_state(state, :decoder), frame)
    process_decoder_reply(state, reply)
  end

  def handle_info({:tcp_closed, _port}, erlrecord_state(host: nil) = state) do
    {:stop, {:shutdown, :tcp_closed}, state}
  end

  def handle_info({:tcp_closed, _port}, state) do
    try_connect(state)
  end

  def handle_info(infoMessage, state) do
    :error_logger.info_report([:unhandled_handle_info, {:msg, infoMessage}])
    {:noreply, state}
  end

  def terminate(_reason, erlrecord_state(socket: nil)) do
    :ok
  end

  def terminate(_reason, erlrecord_state(socket: socket)) do
    :gen_tcp.close(socket)
    :ok
  end

  defp send_data(data, erlrecord_state(socket: socket) = state) do
    case(:gen_tcp.send(socket, data)) do
      :ok ->
        :ok

      {:error, reason} ->
        :error_logger.warning_report([:send_error, {:error, reason}])
    end

    {:noreply, state}
  end

  defp try_connect(
         erlrecord_state(
           host: host,
           port: port,
           parent_pid: parentPid,
           socket: oldSocketPid,
           security_data: curveOptions
         ) = state
       ) do
    case(:gen_tcp.connect(host, port, erlmacro_SOCKET_OPTS([]))) do
      {:ok, socketPid} ->
        case(oldSocketPid) do
          nil ->
            :pass

          _ ->
            :gen_server.cast(parentPid, {:peer_reconnected, self()})
        end

        newState =
          erlrecord_state(state,
            socket: socketPid,
            decoder: :chumak_protocol.new_decoder(curveOptions)
          )

        negotiate_greetings(newState)

      {:error, reason} ->
        :error_logger.error_report([
          {:host, host},
          {:port, port},
          :connection_error,
          {:error, reason}
        ])

        :timer.sleep(erlconst_RECONNECT_TIMEOUT())
        try_connect(state)
    end
  end

  defp negotiate_greetings(
         erlrecord_state(socket: socket, mechanism: mechanism, as_server: asServer) = state
       ) do
    try do
      :ok = send_greetting_step(socket, asServer, mechanism)
      {:ok, greetingFrame} = :gen_tcp.recv(socket, 64, erlconst_GREETINGS_TIMEOUT())

      {:ready, newDecoder} =
        :chumak_protocol.decode(erlrecord_state(state, :decoder), greetingFrame)

      verify_mechanism(state, newDecoder)
    catch
      :error, {:badmatch, error} ->
        :error_logger.error_report([:negotiate_greetings_error, {:error, error}])
        {:stop, error, state}
    end
  end

  defp verify_mechanism(erlrecord_state(mechanism: mechanism) = state, decoder) do
    case(:chumak_protocol.decoder_mechanism(decoder)) do
      ^mechanism ->
        verify_role(state, decoder)

      _ ->
        mismatchError = {:server_error, 'Security mechanism mismatch'}
        :error_logger.error_report([:negotiate_greetings_error, {:error, mismatchError}])
        {:stop, {:shutdown, mismatchError}, state}
    end
  end

  defp verify_role(erlrecord_state(mechanism: :curve, as_server: _asServer) = state, decoder) do
    case(:chumak_protocol.decoder_as_server(decoder)) do
      _ ->
        do_handshake(state, decoder)
    end
  end

  defp verify_role(state, decoder) do
    do_handshake(state, decoder)
  end

  defp do_handshake(erlrecord_state(socket: socket) = state, decoder) do
    peerVersion = :chumak_protocol.decoder_version(decoder)

    case(handshake(erlrecord_state(state, decoder: decoder, peer_version: peerVersion))) do
      {:ok, newState} ->
        :ok = :gen_tcp.controlling_process(socket, self())
        :ok = :inet.setopts(socket, active: :once)
        {:noreply, newState}

      {:error, err, newState} ->
        {:stop, err, newState}
    end
  end

  @spec handshake(state()) :: {:ok, state()} | {:error, term(), state()}

  defp handshake(
         erlrecord_state(
           mechanism: :curve,
           socket: socket,
           as_server: asServer,
           decoder: decoder,
           identity: identity,
           type: socketType,
           resource: resource
         ) = state
       ) do
    socketTypeBin = :string.to_upper(:erlang.atom_to_list(socketType))
    metadata = [{'Socket-Type', socketTypeBin}, {'Identity', identity}, {'Resource', resource}]

    {newDecoder, handshakeResponse} =
      :chumak_curve.security_handshake(socket, decoder, asServer, metadata)

    handle_handshake_data(erlrecord_state(state, decoder: newDecoder), handshakeResponse)
  end

  defp handshake(
         erlrecord_state(mechanism: :null, socket: socket, decoder: decoder, conn_side: side) =
           state
       ) do
    case(side) do
      :client ->
        :ok = send_ready_command(state)

      :server ->
        :ok
    end

    {:ok, incomingReadyFrame} = recv_ready_command(socket)
    {:ok, newDecoder, [readyCommand]} = :chumak_protocol.decode(decoder, incomingReadyFrame)

    case(
      handle_handshake_data(
        erlrecord_state(state, decoder: newDecoder),
        map_ready_command(readyCommand)
      )
    ) do
      {:ok, readyState} when side === :server ->
        :ok = send_ready_command(readyState)
        {:ok, readyState}

      other ->
        other
    end
  end

  defp send_ready_command(
         erlrecord_state(socket: socket, resource: resource, type: type, identity: identity)
       ) do
    readyCommand = :chumak_command.encode_ready(type, identity, resource, %{})
    send_command_to_socket(socket, readyCommand)
  end

  defp map_ready_command(readyCommand) do
    case(:chumak_command.command_name(readyCommand)) do
      :ready ->
        {:ready,
         %{
           :security_data => %{},
           'resource' => :chumak_command.ready_resource(readyCommand),
           'socket-type' => :chumak_command.ready_socket_type(readyCommand),
           'identity' => :chumak_command.ready_identity(readyCommand)
         }}

      :error ->
        {:error, :chumak_command.error_reason(readyCommand)}

      name ->
        {:error, {:invalid_command_before_ready, name}}
    end
  end

  @spec handle_handshake_data(state(), handshake_data()) ::
          {:ok, state()} | {:error, term(), state()}

  defp handle_handshake_data(state, {:error, {:invalid_command_before_ready, _name}} = error) do
    {:error, error, state}
  end

  defp handle_handshake_data(state, {:error, reason}) do
    :error_logger.error_report([:server_error, {:msg, reason}])
    {:error, {:shutdown, {:server_error, reason}}, state}
  end

  defp handle_handshake_data(
         erlrecord_state(multi_socket_type: true, parent_pid: resourceRouterPid) = state,
         {:ready, %{'resource' => resource} = readyData}
       ) do
    case(:gen_server.call(resourceRouterPid, {:route_resource, resource})) do
      {:change_socket, newSocket, {socketType, opts}} ->
        newState =
          apply_opts(erlrecord_state(state, parent_pid: newSocket, type: socketType), opts)

        :erlang.unlink(resourceRouterPid)
        :erlang.link(newSocket)
        handle_ready_response2(newState, readyData)

      :close ->
        send_invalid_resource_error(erlrecord_state(state, :socket), resource)
        {:error, {:shutdown, :invalid_resource}, state}
    end
  end

  defp handle_handshake_data(state, {:ready, readyData}) do
    handle_ready_response2(state, readyData)
  end

  defp handle_ready_response2(
         erlrecord_state(socket: socket, type: socketType) = state,
         %{'socket-type' => peerSocketType} = readyData
       ) do
    case(validate_peer_socket_type(state, readyData)) do
      {:ok, erlrecord_state(parent_pid: parentPid, peer_identity: peerIdentity) = newState} ->
        :gen_server.cast(parentPid, {:peer_ready, self(), peerIdentity})
        {:ok, newState}

      {:error, {:shutdown, :invalid_peer_socket_type}, _} = invSockTypeError ->
        send_invalid_socket_type_error(socket, socketType, peerSocketType)
        invSockTypeError
    end
  end

  defp validate_peer_socket_type(
         erlrecord_state(type: socketType) = state,
         %{'socket-type' => peerSocketTypeList, :security_data => securityData} = metadata
       ) do
    identity = :maps.get('identity', metadata, [])
    peerSocketType = :erlang.list_to_atom(:string.to_lower(peerSocketTypeList))
    patternModule = :chumak_pattern.module(socketType)

    case(patternModule.valid_peer_type(peerSocketType)) do
      :valid ->
        {:ok,
         erlrecord_state(state, step: :ready, security_data: securityData, peer_identity: identity)}

      :invalid ->
        {:error, {:shutdown, :invalid_peer_socket_type}, state}
    end
  end

  defp pending_connect_state(type, host, port, resource, opts, parentPid) do
    state =
      erlrecord_state(
        type: type,
        parent_pid: parentPid,
        host: host,
        port: port,
        resource: resource,
        conn_side: :client
      )

    apply_opts(state, opts)
  end

  defp accepted_state(type, socket, opts, parentPid) do
    :gen_tcp.controlling_process(socket, self())

    state =
      apply_opts(
        erlrecord_state(
          type: type,
          socket: socket,
          parent_pid: parentPid,
          host: nil,
          port: nil,
          conn_side: :server
        ),
        opts
      )

    curveOptions = erlrecord_state(state, :security_data)
    erlrecord_state(state, decoder: :chumak_protocol.new_decoder(curveOptions))
  end

  defp apply_opts(state, []) do
    state
  end

  defp apply_opts(state, [:incoming_queue | opts]) do
    incomingQueue = :queue.new()
    apply_opts(erlrecord_state(state, incoming_queue: incomingQueue), opts)
  end

  defp apply_opts(state, [{:identity, identity} | opts]) do
    apply_opts(erlrecord_state(state, identity: identity), opts)
  end

  defp apply_opts(state, [:pub_compatible_layer | opts]) do
    apply_opts(erlrecord_state(state, pub_compatible_layer: true), opts)
  end

  defp apply_opts(state, [:multi_socket_type | opts]) do
    apply_opts(erlrecord_state(state, multi_socket_type: true), opts)
  end

  defp apply_opts(state, [{:curve_server, true} | opts]) do
    apply_opts(erlrecord_state(state, as_server: true, mechanism: :curve), opts)
  end

  defp apply_opts(state, [{:curve_server, false} | opts]) do
    apply_opts(erlrecord_state(state, as_server: false, mechanism: :null), opts)
  end

  defp apply_opts(state = erlrecord_state(security_data: curveOptions), [{keyType, key} | opts])
       when keyType == :curve_secretkey or keyType == :curve_publickey or
              keyType == :curve_clientkeys do
    apply_opts(
      erlrecord_state(state, security_data: Map.merge(curveOptions, %{keyType => key})),
      opts
    )
  end

  defp apply_opts(state = erlrecord_state(security_data: curveOptions), [
         {:curve_serverkey, key} | opts
       ]) do
    apply_opts(
      erlrecord_state(state,
        mechanism: :curve,
        security_data: Map.merge(curveOptions, %{curve_serverkey: key})
      ),
      opts
    )
  end

  defp recv_ready_command(socket) do
    {:ok, <<4, size>>} = :gen_tcp.recv(socket, 2, erlconst_GREETINGS_TIMEOUT())
    {:ok, frame} = :gen_tcp.recv(socket, size, erlconst_GREETINGS_TIMEOUT())
    {:ok, <<4, size, frame::binary>>}
  end

  defp process_decoder_reply(state, reply) do
    case(reply) do
      {:ok, decoder} ->
        {:noreply, erlrecord_state(state, decoder: decoder)}

      {:ok, decoder, commands} ->
        receive_commands(state, decoder, commands)

      {:error, reason} ->
        :error_logger.error_report([:decode_fail, {:reason, reason}])
        {:stop, :decode_error, state}
    end
  end

  defp send_greetting_step(socket, asServer, mechanism) do
    greeting = :chumak_protocol.build_greeting_frame(asServer, mechanism)

    case(:gen_tcp.send(socket, greeting)) do
      :ok ->
        :ok

      {:error, sendReason} ->
        {:error, {:send_greeting_error, sendReason}}
    end
  end

  defp receive_commands(erlrecord_state(step: :ready) = state, newDecoder, []) do
    {:noreply, erlrecord_state(state, decoder: newDecoder)}
  end

  defp receive_commands(
         erlrecord_state(step: :ready, parent_pid: parentPid) = state,
         newDecoder,
         [command | commands]
       ) do
    case(:chumak_command.command_name(command)) do
      :message ->
        newState = deliver_message(state, command)
        receive_commands(newState, newDecoder, commands)

      :subscribe ->
        subscription = :chumak_command.subscribe_subscription(command)
        :gen_server.cast(parentPid, {:peer_subscribe, self(), subscription})
        receive_commands(state, newDecoder, commands)

      :cancel ->
        subscription = :chumak_command.cancel_subscription(command)
        :gen_server.cast(parentPid, {:peer_cancel_subscribe, self(), subscription})
        receive_commands(state, newDecoder, commands)

      :error ->
        :error_logger.error_report([
          :socket_error,
          {:reason, :chumak_command.error_reason(command)}
        ])

        {:stop, {:shutdown, :peer_error}, state}

      name ->
        {:stop, {:invalid_command, name}}
    end
  end

  defp send_invalid_socket_type_error(socket, socketType, peerSocketType) do
    reasonMsg =
      :io_lib.format('Invalid socket-type ~s for ~p server', [peerSocketType, socketType])

    send_error_to_socket(socket, reasonMsg)
  end

  defp send_invalid_resource_error(socket, resource) do
    reasonMsg = :io_lib.format('Invalid resource: ~s', [resource])
    send_error_to_socket(socket, reasonMsg)
  end

  defp send_error_to_socket(socket, reasonMsg) do
    command = :chumak_command.encode_error(reasonMsg)
    frame = :chumak_protocol.encode_command(command)

    case(:gen_tcp.send(socket, frame)) do
      :ok ->
        :ok

      {:error, reason} ->
        :error_logger.error_msg('Error sending socket error: ~p\n', [reason])
    end
  end

  defp send_command_to_socket(socket, command) do
    :gen_tcp.send(socket, :chumak_protocol.encode_command(command))
  end

  defp deliver_message(
         erlrecord_state(peer_version: {3, 0}, pub_compatible_layer: true, parent_pid: parentPid) =
           state,
         message
       ) do
    data = :chumak_protocol.message_data(message)

    case(data) do
      <<1, subscribeTopic::binary>> ->
        :gen_server.cast(parentPid, {:peer_subscribe, self(), subscribeTopic})

      <<0, unsubscribeTopic::binary>> ->
        :gen_server.cast(parentPid, {:peer_cancel_subscribe, self(), unsubscribeTopic})
    end

    state
  end

  defp deliver_message(
         erlrecord_state(incoming_queue: nil, parent_pid: parentPid) = state,
         message
       ) do
    Kernel.send(parentPid, {:peer_recv_message, message, self()})
    state
  end

  defp deliver_message(state, message) do
    erlrecord_state(
      incoming_queue: incomingQueue,
      msg_buf: buffer,
      parent_pid: parentPid,
      peer_identity: peerIdentity
    ) = state

    newBuffer = buffer ++ [:chumak_protocol.message_data(message)]

    case(:chumak_protocol.message_has_more(message)) do
      true ->
        erlrecord_state(state, msg_buf: newBuffer)

      false ->
        newQueue = :queue.in(newBuffer, incomingQueue)
        Kernel.send(parentPid, {:queue_ready, peerIdentity, self()})
        erlrecord_state(state, msg_buf: [], incoming_queue: newQueue)
    end
  end
end
