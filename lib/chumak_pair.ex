# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:54

defmodule :chumak_pair do
  require Record

  @behaviour :chumak_pattern

  @erlrecordfields_chumak_pair [
    :identity,
    :pair_pid,
    :pending_send,
    :pending_recv,
    :pending_recv_multipart,
    :recv_queue
  ]
  Record.defrecordp(:erlrecord_chumak_pair, :chumak_pair,
    identity: :undefined,
    pair_pid: :undefined,
    pending_send: :undefined,
    pending_recv: :undefined,
    pending_recv_multipart: :undefined,
    recv_queue: :undefined
  )

  def valid_peer_type(:pair) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    state =
      erlrecord_chumak_pair(
        identity: var_identity,
        pair_pid: nil,
        pending_recv: nil,
        pending_recv_multipart: nil,
        pending_send: nil,
        recv_queue: :queue.new()
      )

    {:ok, state}
  end

  def terminate(
        _reason,
        erlrecord_chumak_pair(pending_recv: var_recv, pending_recv_multipart: recvM)
      ) do
    case(var_recv) do
      {:from, from} ->
        :gen_server.reply(from, {:error, :closed})

      _ ->
        :ok
    end

    case(recvM) do
      nil ->
        :ok

      fromM ->
        :gen_server.reply(fromM, {:error, :closed})
    end

    :ok
  end

  def identity(erlrecord_chumak_pair(identity: var_identity)) do
    var_identity
  end

  def peer_flags(_state) do
    {:pair, [:incoming_queue]}
  end

  def accept_peer(erlrecord_chumak_pair(pair_pid: nil) = state, peerPid) do
    {:reply, {:ok, peerPid}, erlrecord_chumak_pair(state, pair_pid: peerPid)}
  end

  def accept_peer(state, peerPid) do
    :error_logger.info_msg('Deny remote peer, this peer already paired')
    :chumak_peer.send_error(peerPid, 'This peer is already paired')
    :chumak_peer.close(peerPid)
    {:reply, {:error, :peer_already_paired}, state}
  end

  def peer_ready(
        erlrecord_chumak_pair(pending_send: pendingSend, pair_pid: peerPid) = state,
        peerPid,
        _identity
      ) do
    case(pendingSend) do
      {from, multipart} ->
        :chumak_peer.send(peerPid, multipart, from)

      nil ->
        :pass
    end

    {:noreply, erlrecord_chumak_pair(state, pending_send: nil)}
  end

  def peer_ready(state, _peerPid, _identity) do
    {:noreply, state}
  end

  def send(state, data, from) do
    send_multipart(state, [data], from)
  end

  def recv(erlrecord_chumak_pair(pending_recv: nil, pending_recv_multipart: nil) = state, from) do
    case(:queue.out(erlrecord_chumak_pair(state, :recv_queue))) do
      {{:value, multipart}, newRecvQueue} ->
        msg = :binary.list_to_bin(multipart)
        {:reply, {:ok, msg}, erlrecord_chumak_pair(state, recv_queue: newRecvQueue)}

      {:empty, _recvQueue} ->
        {:noreply, erlrecord_chumak_pair(state, pending_recv: from)}
    end
  end

  def recv(state, _from) do
    {:reply, {:error, :already_pending_recv}, state}
  end

  def unblock(erlrecord_chumak_pair(pending_recv: pendingRecv) = state, _from)
      when pendingRecv != nil do
    newState = erlrecord_chumak_pair(state, pending_recv: nil)
    :gen_server.reply(pendingRecv, {:error, :again})
    {:reply, :ok, newState}
  end

  def unblock(erlrecord_chumak_pair(pending_recv: nil) = state, _from) do
    {:reply, :ok, state}
  end

  def send_multipart(
        erlrecord_chumak_pair(pending_send: nil, pair_pid: nil) = state,
        multipart,
        from
      ) do
    {:noreply, erlrecord_chumak_pair(state, pending_send: {from, multipart})}
  end

  def send_multipart(
        erlrecord_chumak_pair(pending_send: nil, pair_pid: peerPid) = state,
        multipart,
        from
      ) do
    :chumak_peer.send(peerPid, multipart, from)
    {:noreply, state}
  end

  def send_multipart(state, _multipart, _from) do
    {:reply, {:error, :pendind_send_already_called}, state}
  end

  def recv_multipart(
        erlrecord_chumak_pair(pending_recv: nil, pending_recv_multipart: nil) = state,
        from
      ) do
    case(:queue.out(erlrecord_chumak_pair(state, :recv_queue))) do
      {{:value, multipart}, newRecvQueue} ->
        {:reply, {:ok, multipart}, erlrecord_chumak_pair(state, recv_queue: newRecvQueue)}

      {:empty, _recvQueue} ->
        {:noreply, erlrecord_chumak_pair(state, pending_recv_multipart: from)}
    end
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :already_pending_recv}, state}
  end

  def peer_recv_message(state, _message, _from) do
    {:noreply, state}
  end

  def queue_ready(
        erlrecord_chumak_pair(
          pair_pid: peerPid,
          pending_recv: pendingRecv,
          pending_recv_multipart: pendingRecvMultiPart,
          recv_queue: recvQueue
        ) = state,
        _identity,
        peerPid
      ) do
    {:out, multipart} = :chumak_peer.incoming_queue_out(peerPid)

    newRecvQueue =
      case({pendingRecv, pendingRecvMultiPart}) do
        {nil, nil} ->
          :queue.in(multipart, recvQueue)

        {_, nil} ->
          msg = :binary.list_to_bin(multipart)
          :gen_server.reply(pendingRecv, {:ok, msg})
          recvQueue

        {nil, _} ->
          :gen_server.reply(pendingRecvMultiPart, {:ok, multipart})
          recvQueue
      end

    {:noreply,
     erlrecord_chumak_pair(state,
       pending_recv: nil,
       pending_recv_multipart: nil,
       recv_queue: newRecvQueue
     )}
  end

  def queue_ready(state, _identity, _peerPid) do
    {:noreply, state}
  end

  def peer_disconected(state, _peerPid) do
    {:noreply, erlrecord_chumak_pair(state, pair_pid: nil)}
  end
end
