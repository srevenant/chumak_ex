# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:53

defmodule :chumak_dealer do
  require Record

  @behaviour :chumak_pattern

  @erlrecordfields_chumak_dealer [:identity, :lb, :pending_recv, :state]
  Record.defrecordp(:erlrecord_chumak_dealer, :chumak_dealer,
    identity: :undefined,
    lb: :undefined,
    pending_recv: :none,
    state: :idle
  )

  def valid_peer_type(:rep) do
    :valid
  end

  def valid_peer_type(:router) do
    :valid
  end

  def valid_peer_type(:dealer) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    state = erlrecord_chumak_dealer(identity: var_identity, lb: :chumak_lb.new())
    {:ok, state}
  end

  def identity(erlrecord_chumak_dealer(identity: i)) do
    i
  end

  def terminate(_reason, _state) do
    :ok
  end

  def peer_flags(_state) do
    {:dealer, [:incoming_queue]}
  end

  def accept_peer(state, peerPid) do
    newLb = :chumak_lb.put(erlrecord_chumak_dealer(state, :lb), peerPid)
    {:reply, {:ok, peerPid}, erlrecord_chumak_dealer(state, lb: newLb)}
  end

  def peer_ready(state, _peerPid, _identity) do
    {:noreply, state}
  end

  def send(state, _data, _from) do
    {:reply, {:error, :not_implemented_yet}, state}
  end

  def recv(state, _from) do
    {:reply, {:error, :not_implemented_yet}, state}
  end

  def send_multipart(erlrecord_chumak_dealer(lb: lB) = state, multipart, from) do
    case(:chumak_lb.get(lB)) do
      :none ->
        {:reply, {:error, :no_connected_peers}, state}

      {newLB, peerPid} ->
        :chumak_peer.send(peerPid, multipart, from)
        {:noreply, erlrecord_chumak_dealer(state, lb: newLB)}
    end
  end

  def recv_multipart(erlrecord_chumak_dealer(state: :idle, lb: lB) = state, from) do
    case(:chumak_lb.get(lB)) do
      :none ->
        {:noreply, erlrecord_chumak_dealer(state, state: :wait_req, pending_recv: {:from, from})}

      {newLB, peerPid} ->
        direct_recv_multipart(erlrecord_chumak_dealer(state, lb: newLB), peerPid, peerPid, from)
    end
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def peer_recv_message(state, _message, _from) do
    {:noreply, state}
  end

  def unblock(erlrecord_chumak_dealer(pending_recv: {:from, pendingRecv}) = state, _from) do
    newState = erlrecord_chumak_dealer(state, pending_recv: :none, state: :idle)
    :gen_server.reply(pendingRecv, {:error, :again})
    {:reply, :ok, newState}
  end

  def unblock(erlrecord_chumak_dealer(state: :idle) = state, _from) do
    {:reply, :ok, state}
  end

  def queue_ready(
        erlrecord_chumak_dealer(state: :wait_req, pending_recv: {:from, pendingRecv}) = state,
        _identity,
        peerPid
      ) do
    futureState =
      case(:chumak_peer.incoming_queue_out(peerPid)) do
        {:out, messages} ->
          :gen_server.reply(pendingRecv, {:ok, messages})
          erlrecord_chumak_dealer(state, state: :idle, pending_recv: :none)

        :empty ->
          :gen_server.reply(pendingRecv, {:error, :queue_empty})
          erlrecord_chumak_dealer(state, state: :idle, pending_recv: :none)

        {:error, info} ->
          :error_logger.info_msg('can\'t get message out in ~p with reason: ~p~n', [
            :chumak_dealer,
            info
          ])

          state
      end

    {:noreply, futureState}
  end

  def queue_ready(state, _identity, _peerPid) do
    {:noreply, state}
  end

  def peer_disconected(erlrecord_chumak_dealer(lb: lB) = state, peerPid) do
    newLB = :chumak_lb.delete(lB, peerPid)
    {:noreply, erlrecord_chumak_dealer(state, lb: newLB)}
  end

  defp direct_recv_multipart(erlrecord_chumak_dealer(lb: lB) = state, firstPeerPid, peerPid, from) do
    case(:chumak_peer.incoming_queue_out(peerPid)) do
      {:out, messages} ->
        {:reply, {:ok, messages}, state}

      :empty ->
        case(:chumak_lb.get(lB)) do
          {newLB, ^firstPeerPid} ->
            {:noreply,
             erlrecord_chumak_dealer(state,
               state: :wait_req,
               pending_recv: {:from, from},
               lb: newLB
             )}

          {newLB, otherPeerPid} ->
            direct_recv_multipart(
              erlrecord_chumak_dealer(state, lb: newLB),
              firstPeerPid,
              otherPeerPid,
              from
            )
        end
    end
  end
end
