# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:59

defmodule :chumak_sub do
  require Record

  @behaviour :chumak_pattern

  @erlrecordfields_chumak_sub [
    :identity,
    :topics,
    :peers,
    :pending_recv,
    :pending_recv_multipart,
    :recv_queue,
    :xsub
  ]
  Record.defrecordp(:erlrecord_chumak_sub, :chumak_sub,
    identity: :undefined,
    topics: :undefined,
    peers: :undefined,
    pending_recv: nil,
    pending_recv_multipart: :undefined,
    recv_queue: :undefined,
    xsub: false
  )

  def valid_peer_type(:pub) do
    :valid
  end

  def valid_peer_type(:xpub) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    init(var_identity, [])
  end

  def init(var_identity, opts) do
    state =
      erlrecord_chumak_sub(
        identity: var_identity,
        topics: [],
        peers: [],
        recv_queue: :queue.new(),
        pending_recv: nil,
        pending_recv_multipart: nil
      )

    {:ok, apply_opts(state, opts)}
  end

  def terminate(_reason, erlrecord_chumak_sub(pending_recv: var_recv)) do
    case(var_recv) do
      {:from, from} ->
        :gen_server.reply(from, {:error, :closed})

      _ ->
        :ok
    end

    :ok
  end

  defp apply_opts(state, []) do
    state
  end

  defp apply_opts(state, [:xsub | opts]) do
    apply_opts(erlrecord_chumak_sub(state, xsub: true), opts)
  end

  def identity(erlrecord_chumak_sub(identity: var_identity)) do
    var_identity
  end

  def peer_flags(erlrecord_chumak_sub(xsub: true)) do
    {:xsub, [:incoming_queue]}
  end

  def peer_flags(_state) do
    {:sub, [:incoming_queue]}
  end

  def accept_peer(erlrecord_chumak_sub(peers: peers) = state, peerPid) do
    newPeers = [peerPid | peers]
    {:reply, {:ok, peerPid}, erlrecord_chumak_sub(state, peers: newPeers)}
  end

  def peer_ready(erlrecord_chumak_sub(topics: topics) = state, peerPid, _identity) do
    send_subscriptions(topics, peerPid)
    {:noreply, state}
  end

  def send(state, data, from) do
    send_multipart(state, [data], from)
  end

  def recv(erlrecord_chumak_sub(pending_recv: nil, recv_queue: recvQueue) = state, from) do
    case(:queue.out(recvQueue)) do
      {{:value, multipart}, newRecvQueue} ->
        fullMsg = :binary.list_to_bin(multipart)
        {:reply, {:ok, fullMsg}, erlrecord_chumak_sub(state, recv_queue: newRecvQueue)}

      {:empty, _recvQueue} ->
        {:noreply,
         erlrecord_chumak_sub(state, pending_recv: {:from, from}, pending_recv_multipart: false)}
    end
  end

  def recv(state, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def unblock(erlrecord_chumak_sub(pending_recv: {:from, pendingRecv}) = state, _from) do
    newState = erlrecord_chumak_sub(state, pending_recv: nil, pending_recv_multipart: nil)
    :gen_server.reply(pendingRecv, {:error, :again})
    {:reply, :ok, newState}
  end

  def unblock(erlrecord_chumak_sub(pending_recv: nil) = state, _from) do
    {:reply, :ok, state}
  end

  def send_multipart(erlrecord_chumak_sub(xsub: true, peers: peers) = state, multipart, _from) do
    :lists.foreach(fn peerPid -> :chumak_peer.send(peerPid, multipart) end, peers)
    {:reply, :ok, state}
  end

  def send_multipart(state, _multipart, _from) do
    {:reply, {:error, :not_use}, state}
  end

  def recv_multipart(erlrecord_chumak_sub(pending_recv: nil, recv_queue: recvQueue) = state, from) do
    case(:queue.out(recvQueue)) do
      {{:value, multipart}, newRecvQueue} ->
        {:reply, {:ok, multipart}, erlrecord_chumak_sub(state, recv_queue: newRecvQueue)}

      {:empty, _recvQueue} ->
        {:noreply,
         erlrecord_chumak_sub(state, pending_recv: {:from, from}, pending_recv_multipart: true)}
    end
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def peer_recv_message(state, _message, _from) do
    {:noreply, state}
  end

  def queue_ready(state, _identity, peerPid) do
    case(:chumak_peer.incoming_queue_out(peerPid)) do
      {:out, multipart} ->
        {:noreply, handle_queue_ready(state, multipart)}

      :empty ->
        {:noreply, state}

      {:error, info} ->
        :error_logger.info_msg('can\'t get message out in ~p with reason: ~p~n', [
          :chumak_sub,
          info
        ])

        {:noreply, state}
    end
  end

  def peer_disconected(erlrecord_chumak_sub(peers: peers) = state, peerPid) do
    newPeers = :lists.delete(peerPid, peers)
    {:noreply, erlrecord_chumak_sub(state, peers: newPeers)}
  end

  def subscribe(erlrecord_chumak_sub(topics: topics, peers: peers) = state, topic) do
    send_subscription_to_peers(topic, peers)
    {:noreply, erlrecord_chumak_sub(state, topics: [topic | topics])}
  end

  def cancel(erlrecord_chumak_sub(topics: topics, peers: peers) = state, topic) do
    send_cancel_subscription_to_peers(topic, peers)
    newTopics = :lists.delete(topic, topics)
    {:noreply, erlrecord_chumak_sub(state, topics: newTopics)}
  end

  def peer_reconnected(erlrecord_chumak_sub(topics: topics) = state, peerPid) do
    send_subscriptions(topics, peerPid)
    {:noreply, state}
  end

  defp send_subscriptions(topics, peerPid) do
    :lists.foreach(fn topic -> :chumak_peer.send_subscription(peerPid, topic) end, topics)
  end

  defp send_subscription_to_peers(topic, peers) do
    :lists.foreach(fn peerPid -> :chumak_peer.send_subscription(peerPid, topic) end, peers)
  end

  defp send_cancel_subscription_to_peers(topic, peers) do
    :lists.foreach(fn peerPid -> :chumak_peer.send_cancel_subscription(peerPid, topic) end, peers)
  end

  defp handle_queue_ready(
         erlrecord_chumak_sub(recv_queue: recvQueue, pending_recv: nil) = state,
         data
       ) do
    newRecvQueue = :queue.in(data, recvQueue)
    erlrecord_chumak_sub(state, recv_queue: newRecvQueue)
  end

  defp handle_queue_ready(
         erlrecord_chumak_sub(
           pending_recv: {:from, pendingRecv},
           pending_recv_multipart: isPendingMultipart
         ) = state,
         data
       ) do
    case(isPendingMultipart) do
      true ->
        :gen_server.reply(pendingRecv, {:ok, data})

      false ->
        fullMsg = :binary.list_to_bin(data)
        :gen_server.reply(pendingRecv, {:ok, fullMsg})
    end

    erlrecord_chumak_sub(state, pending_recv: nil, pending_recv_multipart: nil)
  end
end
