# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:51

defmodule :chumak_bind do
  # Begin included file: chumak.hrl

  @type transport() :: :tcp

  @type socket_type() ::
          :req | :rep | :dealer | :router | :pub | :xpub | :sub | :xsub | :push | :pull | :pair

  @typep z85_key() :: char_list()

  @typep socket_option() ::
           :curve_server
           | :curve_publickey
           | :curve_secretkey
           | :curve_serverkey
           | :curve_clientkeys

  @typep security_mechanism() :: :null | :curve

  defmacrop erlmacro_SOCKET_OPTS(opts) do
    quote do
      :lists.append([:binary, {:active, false}, {:reuseaddr, true}], unquote(opts))
    end
  end

  defmacrop erlconst_GREETINGS_TIMEOUT() do
    quote do
      1000
    end
  end

  defmacrop erlconst_RECONNECT_TIMEOUT() do
    quote do
      2000
    end
  end

  # End included file: chumak.hrl

  @spec start_link(char_list(), number()) :: {:ok, pid()} | {:error, term()}

  def start_link(host, port) do
    parentPid = self()

    case(getaddr(host)) do
      {:ok, addr} ->
        case(:gen_tcp.listen(port, erlmacro_SOCKET_OPTS(ip: addr))) do
          {:ok, listenSocket} ->
            pid = spawn_link(__MODULE__, :listener, [listenSocket, parentPid])
            {:ok, pid}

          {:error, reason} ->
            :error_logger.error_report([
              :bind_error,
              {:host, host},
              {:addr, addr},
              {:port, port},
              :listen_error,
              {:error, reason}
            ])

            {:error, reason}
        end

      {:error, ipReason} ->
        :error_logger.error_report([
          :bind_error,
          {:host, host},
          :getaddr_error,
          {:error, ipReason}
        ])

        {:error, ipReason}
    end
  end

  def listener(listenSocket, parentPid) do
    try do
      {:ok, socket} = :gen_tcp.accept(listenSocket)
      {:ok, peerPid} = :gen_server.call(parentPid, {:accept, socket})
      :ok = :gen_tcp.controlling_process(socket, peerPid)
      :gen_server.cast(peerPid, :negotiate_greetings)
      listener(listenSocket, parentPid)
    catch
      :error, {:badmatch, {:error, :closed}} ->
        :error_logger.info_report({:bind_closed})

      :error, {:badmatch, error} ->
        :error_logger.error_report([:accept_error, {:error, error}])
        listener(listenSocket, parentPid)
    end
  end

  @spec getaddr(char_list()) :: {:ok, :inet.ip_address() | :any} | {:error, term()}

  defp getaddr('*') do
    {:ok, :any}
  end

  defp getaddr(host) do
    :inet.getaddr(host, :inet)
  end
end
