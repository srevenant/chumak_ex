# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:56

defmodule :chumak_push do
  require Record

  @behaviour :chumak_pattern

  @erlrecordfields_chumak_push [:identity, :lb]
  Record.defrecordp(:erlrecord_chumak_push, :chumak_push, identity: :undefined, lb: :undefined)

  def valid_peer_type(:pull) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    state = erlrecord_chumak_push(identity: var_identity, lb: :chumak_lb.new())
    {:ok, state}
  end

  def terminate(_reason, _state) do
    :ok
  end

  def identity(erlrecord_chumak_push(identity: var_identity)) do
    var_identity
  end

  def peer_flags(_state) do
    {:push, []}
  end

  def accept_peer(state, peerPid) do
    newLb = :chumak_lb.put(erlrecord_chumak_push(state, :lb), peerPid)
    {:reply, {:ok, peerPid}, erlrecord_chumak_push(state, lb: newLb)}
  end

  def peer_ready(state, _peerPid, _identity) do
    {:noreply, state}
  end

  def send(state, data, from) do
    send_multipart(state, [data], from)
  end

  def recv(state, from) do
    recv_multipart(state, from)
  end

  def send_multipart(erlrecord_chumak_push(lb: lB) = state, multipart, from) do
    case(:chumak_lb.get(lB)) do
      :none ->
        {:reply, {:error, :no_connected_peers}, state}

      {newLB, peerPid} ->
        :chumak_peer.send(peerPid, multipart, from)
        {:noreply, erlrecord_chumak_push(state, lb: newLB)}
    end
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :not_use}, state}
  end

  def unblock(state, _from) do
    {:reply, {:error, :not_use}, state}
  end

  def peer_recv_message(state, _message, _from) do
    {:noreply, state}
  end

  def queue_ready(state, _identity, _peerPid) do
    {:noreply, state}
  end

  def peer_disconected(erlrecord_chumak_push(lb: lB) = state, peerPid) do
    newLB = :chumak_lb.delete(lB, peerPid)
    {:noreply, erlrecord_chumak_push(state, lb: newLB)}
  end
end
