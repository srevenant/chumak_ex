# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:57

defmodule :chumak_req do
  require Record

  @behaviour :chumak_pattern

  @typep req_state() :: :ready | :wait_reply | :wait_more_msg | :wait_recv

  @erlrecordfields_chumak_req [:identity, :lb, :state, :last_peer_sent, :pending_recv, :msg_buf]
  Record.defrecordp(:erlrecord_chumak_req, :chumak_req,
    identity: :undefined,
    lb: :undefined,
    state: :ready,
    last_peer_sent: nil,
    pending_recv: nil,
    msg_buf: []
  )

  def valid_peer_type(:rep) do
    :valid
  end

  def valid_peer_type(:router) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    state = erlrecord_chumak_req(identity: var_identity, lb: :chumak_lb.new(), msg_buf: [])
    {:ok, state}
  end

  def terminate(_reason, erlrecord_chumak_req(pending_recv: var_recv)) do
    case(var_recv) do
      {:from, from} ->
        :gen_server.reply(from, {:error, :closed})

      _ ->
        :ok
    end

    :ok
  end

  def identity(erlrecord_chumak_req(identity: i)) do
    i
  end

  def peer_flags(_state) do
    {:req, []}
  end

  def accept_peer(state, peerPid) do
    newLb = :chumak_lb.put(erlrecord_chumak_req(state, :lb), peerPid)
    {:reply, {:ok, peerPid}, erlrecord_chumak_req(state, lb: newLb)}
  end

  def peer_ready(state, _peerPid, _identity) do
    {:noreply, state}
  end

  def send(erlrecord_chumak_req(lb: lB, state: :ready) = state, data, from) do
    case(:chumak_lb.get(lB)) do
      :none ->
        {:reply, {:error, :no_connected_peers}, state}

      {newLB, peerPid} ->
        :chumak_peer.send(peerPid, [<<>>, data], from)

        {:noreply,
         erlrecord_chumak_req(state, lb: newLB, state: :wait_reply, last_peer_sent: peerPid)}
    end
  end

  def send(state, _data, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def recv(erlrecord_chumak_req(state: :wait_recv, msg_buf: buffer) = state, _from) do
    fullMsg = :binary.list_to_bin(buffer)
    {:reply, {:ok, fullMsg}, erlrecord_chumak_req(state, state: :ready, msg_buf: [])}
  end

  def recv(erlrecord_chumak_req(state: :ready) = state, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def recv(erlrecord_chumak_req(state: socketState, pending_recv: pendingRecv) = state, from) do
    case({socketState, pendingRecv}) do
      {:wait_reply, nil} ->
        {:noreply, erlrecord_chumak_req(state, pending_recv: from)}

      {:wait_more_msg, nil} ->
        {:noreply, erlrecord_chumak_req(state, pending_recv: from)}

      _ ->
        {:reply, {:error, :efsm}, state}
    end
  end

  def send_multipart(state, _multipart, _from) do
    {:reply, {:error, :not_implemented_yet}, state}
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :not_implemented_yet}, state}
  end

  def unblock(erlrecord_chumak_req(pending_recv: {:from, pendingRecv}) = state, _from) do
    newState = erlrecord_chumak_req(state, pending_recv: nil)
    :gen_server.reply(pendingRecv, {:error, :again})
    {:reply, :ok, newState}
  end

  def unblock(erlrecord_chumak_req(pending_recv: nil) = state, _from) do
    {:reply, :ok, state}
  end

  def peer_recv_message(
        erlrecord_chumak_req(state: :wait_reply, last_peer_sent: from) = state,
        message,
        from
      ) do
    case(:chumak_protocol.message_data(message)) do
      <<>> ->
        {:noreply, erlrecord_chumak_req(state, state: :wait_more_msg)}

      frame ->
        :error_logger.warning_report(
          {:invalid_delimiter_frame, {:pattern, :req}, {:obtained_frame, frame},
           {:expected_frame, <<>>}}
        )

        {:noreply, state}
    end
  end

  def peer_recv_message(
        erlrecord_chumak_req(state: :wait_more_msg, last_peer_sent: from) = state,
        message,
        from
      ) do
    erlrecord_chumak_req(msg_buf: buffer, pending_recv: pendingRecv) = state
    newBuffer = buffer ++ [:chumak_protocol.message_data(message)]

    case({:chumak_protocol.message_has_more(message), pendingRecv}) do
      {true, _} ->
        {:noreply, erlrecord_chumak_req(state, state: :wait_more_msg, msg_buf: newBuffer)}

      {false, nil} ->
        {:noreply, erlrecord_chumak_req(state, state: :wait_recv, msg_buf: newBuffer)}

      {false, ^pendingRecv} ->
        fullMsg = :binary.list_to_bin(newBuffer)
        :gen_server.reply(pendingRecv, {:ok, fullMsg})
        {:noreply, erlrecord_chumak_req(state, state: :ready, msg_buf: [], pending_recv: nil)}
    end
  end

  def peer_recv_message(
        erlrecord_chumak_req(last_peer_sent: lastPeer, state: s) = state,
        message,
        from
      ) do
    :error_logger.info_report(
      {:discard_message, {:last_peer_sent, lastPeer}, {:peer_sent, from}, {:state, s},
       {:message, message}}
    )

    {:noreply, state}
  end

  def queue_ready(state, _identity, _from) do
    {:noreply, state}
  end

  def peer_disconected(erlrecord_chumak_req(lb: lB) = state, peerPid) do
    newLB = :chumak_lb.delete(lB, peerPid)
    {:noreply, erlrecord_chumak_req(state, lb: newLB)}
  end
end
