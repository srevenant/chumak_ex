# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:50

defmodule :chumak do
  # Begin included file: chumak.hrl

  @type transport() :: :tcp

  @type socket_type() ::
          :req | :rep | :dealer | :router | :pub | :xpub | :sub | :xsub | :push | :pull | :pair

  @typep z85_key() :: char_list()

  @typep socket_option() ::
           :curve_server
           | :curve_publickey
           | :curve_secretkey
           | :curve_serverkey
           | :curve_clientkeys

  @type security_mechanism() :: :null | :curve

  defmacrop erlmacro_SOCKET_OPTS(opts) do
    quote do
      :lists.append([:binary, {:active, false}, {:reuseaddr, true}], unquote(opts))
    end
  end

  defmacrop erlconst_GREETINGS_TIMEOUT() do
    quote do
      1000
    end
  end

  defmacrop erlconst_RECONNECT_TIMEOUT() do
    quote do
      2000
    end
  end

  # End included file: chumak.hrl

  @behaviour :application

  defmacrop erlconst_SUPERVISOR() do
    quote do
      :chumak_sup
    end
  end

  @typep version() :: {integer(), integer(), integer()}

  def start(_startType, _startArgs) do
    erlconst_SUPERVISOR().start_link()
  end

  def stop(_state) do
    :ok
  end

  @spec socket(socket_type(), char_list()) :: {:ok, pid()} | {:error, atom()}

  def socket(type, identity) when is_atom(type) and is_list(identity) do
    erlconst_SUPERVISOR().start_socket(type, identity)
  end

  def socket(type) when is_atom(type) do
    erlconst_SUPERVISOR().start_socket(type)
  end

  @spec set_socket_option(pid(), socket_option(), term()) :: :ok | {:error, atom()}

  def set_socket_option(socketPid, option, value) when is_pid(socketPid) and is_atom(option) do
    :gen_server.call(socketPid, {:set_option, option, value})
  end

  @spec connect(pid(), transport(), char_list(), integer(), term()) ::
          {:ok, pid()} | {:error, atom()}

  def connect(socketPid, transport, host, port, var_resource)
      when is_pid(socketPid) and is_atom(transport) and is_list(host) and is_number(port) and
             is_list(var_resource) do
    :gen_server.call(socketPid, {:connect, transport, host, port, var_resource})
  end

  def connect(socketPid, transport, host, port) do
    connect(socketPid, transport, host, port, [])
  end

  @spec bind(pid(), transport(), char_list(), integer()) :: {:ok, pid()} | {:error, term()}

  def bind(socketPid, transport, host, port)
      when is_pid(socketPid) and is_atom(transport) and is_list(host) and is_number(port) do
    :gen_server.call(socketPid, {:bind, transport, host, port})
  end

  @spec send(pid(), binary()) :: :ok

  def send(socketPid, data) when is_pid(socketPid) and is_binary(data) do
    :gen_server.call(socketPid, {:send, data}, :infinity)
  end

  def send(socketPid, data) when is_pid(socketPid) and is_list(data) do
    __MODULE__.send(socketPid, :erlang.list_to_binary(data))
  end

  @spec send_multipart(pid(), list(binary())) :: :ok

  def send_multipart(socketPid, multipart) when is_pid(socketPid) and is_list(multipart) do
    :gen_server.call(socketPid, {:send_multipart, multipart}, :infinity)
  end

  @spec recv(pid()) :: {:ok, binary()} | {:error, atom()}

  def recv(socketPid) when is_pid(socketPid) do
    :gen_server.call(socketPid, :recv, :infinity)
  end

  @spec recv_multipart(pid()) :: {:ok, list(binary())} | {:error, atom()}

  def recv_multipart(socketPid) when is_pid(socketPid) do
    :gen_server.call(socketPid, :recv_multipart, :infinity)
  end

  @spec unblock(pid()) :: :ok

  def unblock(socketPid) when is_pid(socketPid) do
    :gen_server.call(socketPid, :unblock)
  end

  @spec subscribe(pid(), binary()) :: :ok

  def subscribe(socketPid, topic) when is_pid(socketPid) and is_binary(topic) do
    :gen_server.cast(socketPid, {:subscribe, topic})
  end

  def subscribe(socketPid, topic) when is_pid(socketPid) and is_list(topic) do
    subscribe(socketPid, :erlang.list_to_binary(topic))
  end

  @spec cancel(pid(), binary()) :: :ok

  def cancel(socketPid, topic) when is_pid(socketPid) and is_binary(topic) do
    :gen_server.cast(socketPid, {:cancel, topic})
  end

  def cancel(socketPid, topic) when is_pid(socketPid) and is_list(topic) do
    cancel(socketPid, :erlang.list_to_binary(topic))
  end

  @spec resource() :: {:ok, pid()} | {:error, atom()}

  def resource() do
    erlconst_SUPERVISOR().start_resource()
  end

  @spec attach_resource(pid(), binary(), pid()) :: :ok

  def attach_resource(resourcePid, var_resource, socketPid) do
    :gen_server.cast(resourcePid, {:attach, var_resource, socketPid})
  end

  @spec detach_resource(pid(), binary()) :: :ok

  def detach_resource(resourcePid, var_resource) do
    :gen_server.cast(resourcePid, {:detach, var_resource})
  end

  @spec version() :: {:ok, version()} | {:error, atom()}

  def version() do
    case(:application.get_application(:chumak)) do
      {:ok, :chumak} ->
        {:ok, return_version()}

      :undefined ->
        {:error, :application_not_started}
    end
  end

  defp return_version() do
    {:ok, var_version} = :application.get_key(:chumak, :vsn)
    [x, y, z] = :string.tokens(var_version, '.')
    major = :erlang.list_to_integer(x)
    minor = :erlang.list_to_integer(y)
    patch = :erlang.list_to_integer(z)
    {major, minor, patch}
  end
end
