# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:52

defmodule :chumak_command do
  require Record

  # Begin included file: chumak.hrl

  @type transport() :: :tcp

  @type socket_type() ::
          :req | :rep | :dealer | :router | :pub | :xpub | :sub | :xsub | :push | :pull | :pair

  @typep z85_key() :: char_list()

  @typep socket_option() ::
           :curve_server
           | :curve_publickey
           | :curve_secretkey
           | :curve_serverkey
           | :curve_clientkeys

  @typep security_mechanism() :: :null | :curve

  defmacrop erlmacro_SOCKET_OPTS(opts) do
    quote do
      :lists.append([:binary, {:active, false}, {:reuseaddr, true}], unquote(opts))
    end
  end

  defmacrop erlconst_GREETINGS_TIMEOUT() do
    quote do
      1000
    end
  end

  defmacrop erlconst_RECONNECT_TIMEOUT() do
    quote do
      2000
    end
  end

  # End included file: chumak.hrl

  @erlrecordfields_ready [:socket_type, :identity, :resource, :metadata]
  Record.defrecordp(:erlrecord_ready, :ready,
    socket_type: nil,
    identity: [],
    resource: [],
    metadata: %{}
  )

  @erlrecordfields_ping []
  Record.defrecordp(:erlrecord_ping, :ping, [])

  @erlrecordfields_error [:reason]
  Record.defrecordp(:erlrecord_error, :error, reason: :undefined)

  @erlrecordfields_subscribe [:subscription]
  Record.defrecordp(:erlrecord_subscribe, :subscribe, subscription: :undefined)

  @erlrecordfields_cancel [:subscription]
  Record.defrecordp(:erlrecord_cancel, :cancel, subscription: :undefined)

  @erlrecordfields_hello []
  Record.defrecordp(:erlrecord_hello, :hello, [])

  @erlrecordfields_welcome []
  Record.defrecordp(:erlrecord_welcome, :welcome, [])

  @erlrecordfields_initiate [:metadata, :client_public_key]
  Record.defrecordp(:erlrecord_initiate, :initiate, metadata: %{}, client_public_key: :undefined)

  @erlrecordfields_message []
  Record.defrecordp(:erlrecord_message, :message, [])

  @typep ready() :: ready()

  @typep ping() :: ping()

  @typep error() :: error()

  @typep subscribe() :: subscribe()

  @typep cancel() :: cancel()

  @typep hello() :: record(:erlrecord_hello, [])

  @typep welcome() :: record(:erlrecord_welcome, [])

  @typep initiate() ::
           record(:erlrecord_initiate, metadata: map(), client_public_key: :undefined | binary())

  @typep message() :: record(:erlrecord_message, [])

  @type command() ::
          ready()
          | ping()
          | error()
          | subscribe()
          | cancel()
          | hello()
          | welcome()
          | initiate()
          | ready()
          | message()

  @typep ready_decode_error() :: :wrong_ready_message

  @typep decode_error() :: ready_decode_error()

  @spec decode(:chumak_protocol.frame(), :chumak_curve.curve_data()) ::
          {:ok, command(), :chumak_curve.curve_data()} | {:error, decode_error()}

  def decode(frame, curveData) do
    <<commandNameByteSize, frame2::binary>> = frame
    commandNameBitSize = 8 * commandNameByteSize
    <<commandName::size(commandNameBitSize)-bitstring, commandBody::binary>> = frame2
    decode_message(:erlang.binary_to_atom(commandName, :utf8), commandBody, curveData)
  end

  @spec command_name(command()) :: atom()

  def command_name(command) do
    :erlang.element(1, command)
  end

  @spec ready_socket_type(ready()) :: atom()

  def ready_socket_type(erlrecord_ready(socket_type: socketType)) do
    socketType
  end

  @spec ready_identity(ready()) :: char_list()

  def ready_identity(erlrecord_ready(identity: identity)) do
    identity
  end

  @spec ready_resource(ready()) :: char_list()

  def ready_resource(erlrecord_ready(resource: resource)) do
    resource
  end

  @spec ready_metadata(ready()) :: map()

  def ready_metadata(erlrecord_ready(metadata: metadata)) do
    metadata
  end

  @spec initiate_metadata(initiate()) :: map()

  def initiate_metadata(erlrecord_initiate(metadata: metadata)) do
    metadata
  end

  @spec initiate_client_key(initiate()) :: binary()

  def initiate_client_key(erlrecord_initiate(client_public_key: value)) do
    value
  end

  @spec encode_ready(atom(), char_list(), char_list(), map()) :: binary()

  def encode_ready(socketType, identity, resource, metadata) when is_atom(socketType) do
    socketTypeBin = :string.to_upper(:erlang.atom_to_list(socketType))

    properties =
      :lists.flatten([
        {'Socket-Type', socketTypeBin},
        {'Identity', identity},
        {'Resource', resource},
        :maps.to_list(metadata)
      ])

    propertiesFrame = encode_ready_properties(properties)
    <<5, "READY", propertiesFrame::binary>>
  end

  @spec error_reason(error()) :: char_list()

  def error_reason(erlrecord_error(reason: reason)) do
    reason
  end

  @spec encode_error(char_list()) :: binary()

  def encode_error(reason) when is_list(reason) do
    reasonBin = :erlang.list_to_binary(reason)
    reasonSize = byte_size(reasonBin)
    <<5, "ERROR", reasonSize, reasonBin::binary>>
  end

  @spec encode_subscribe(binary()) :: binary()

  def encode_subscribe(subscription) when is_binary(subscription) do
    <<9, "SUBSCRIBE", subscription::binary>>
  end

  @spec subscribe_subscription(subscribe()) :: binary()

  def subscribe_subscription(erlrecord_subscribe(subscription: subscription)) do
    subscription
  end

  @spec encode_cancel(binary()) :: binary()

  def encode_cancel(subscription) when is_binary(subscription) do
    <<6, "CANCEL", subscription::binary>>
  end

  @spec cancel_subscription(cancel()) :: binary()

  def cancel_subscription(erlrecord_cancel(subscription: subscription)) do
    subscription
  end

  defp decode_message(:READY, body, %{mechanism: :curve} = curveData) do
    try do
      decode_curve_ready_message(body, curveData)
    catch
      :error, {:badmatch, _error} ->
        {:error, :wrong_ready_message}
    else
      result ->
        result
    end
  end

  defp decode_message(:READY, body, securityData) do
    try do
      decode_ready_message(erlrecord_ready([]), body)
    catch
      :error, {:badmatch, _} ->
        {:error, :wrong_ready_message}
    else
      message ->
        {:ok, message, securityData}
    end
  end

  defp decode_message(:PING, _body, securityData) do
    {:ok, erlrecord_ping([]), securityData}
  end

  defp decode_message(:ERROR, body, securityData) do
    try do
      decode_error_message(body)
    catch
      :error, {:badmatch, _} ->
        {:error, :wrong_error_message}
    else
      message ->
        {:ok, message, securityData}
    end
  end

  defp decode_message(:SUBSCRIBE, body, securityData) do
    {:ok, erlrecord_subscribe(subscription: body), securityData}
  end

  defp decode_message(:CANCEL, body, securityData) do
    {:ok, erlrecord_cancel(subscription: body), securityData}
  end

  defp decode_message(:HELLO, body, curveData) do
    try do
      decode_hello_message(body, curveData)
    catch
      :error, {:badmatch, _} ->
        {:error, :wrong_hello_message}
    else
      result ->
        result
    end
  end

  defp decode_message(:WELCOME, body, curveData) do
    try do
      decode_welcome_message(body, curveData)
    catch
      :error, {:badmatch, _} ->
        {:error, :wrong_welcome_message}
    else
      result ->
        result
    end
  end

  defp decode_message(:INITIATE, body, curveData) do
    try do
      decode_initiate_message(body, curveData)
    catch
      :error, {:badmatch, _} ->
        {:error, :wrong_initiate_message}
    else
      result ->
        result
    end
  end

  defp decode_message(:MESSAGE, body, curveData) do
    try do
      decode_curve_message(body, curveData)
    catch
      :error, {:badmatch, _} ->
        {:error, :wrong_message}
    else
      result ->
        result
    end
  end

  defp decode_ready_message(command, message) do
    properties = decode_ready_properties(message)
    :maps.fold(&append_ready_property/3, command, properties)
  end

  defp append_ready_property('socket-type', socketType, readyCommand) do
    erlrecord_ready(readyCommand, socket_type: :string.to_lower(socketType))
  end

  defp append_ready_property('identity', identity, readyCommand) do
    erlrecord_ready(readyCommand, identity: identity)
  end

  defp append_ready_property('resource', resource, readyCommand) do
    erlrecord_ready(readyCommand, resource: resource)
  end

  defp append_ready_property(name, value, erlrecord_ready(metadata: metaData) = readyCommand) do
    erlrecord_ready(readyCommand, metadata: Map.merge(metaData, %{name => value}))
  end

  defp decode_ready_properties(metaData) do
    decode_ready_properties(metaData, %{})
  end

  defp decode_ready_properties(<<>>, map) do
    map
  end

  defp decode_ready_properties(<<propertyNameLen, rest::binary>>, map) do
    <<propertyName::size(propertyNameLen)-binary, propertyValueLen::32, rest2::binary>> = rest
    <<propertyValue::size(propertyValueLen)-binary, rest3::binary>> = rest2
    name = :string.to_lower(:erlang.binary_to_list(propertyName))
    value = :erlang.binary_to_list(propertyValue)
    decode_ready_properties(rest3, Map.merge(map, %{name => value}))
  end

  def encode_ready_properties([]) do
    ""
  end

  def encode_ready_properties([{name, value} | properties]) do
    nameBin = :erlang.list_to_binary(name)
    valueBin = :erlang.list_to_binary(value)
    nameLen = byte_size(nameBin)
    valueLen = byte_size(valueBin)
    tail = encode_ready_properties(properties)
    <<nameLen, nameBin::binary, valueLen::32, valueBin::binary, tail::binary>>
  end

  defp decode_error_message(body) do
    <<size, remaingBody::binary>> = body
    <<reason::size(size)-binary>> = remaingBody
    erlrecord_error(reason: :erlang.binary_to_list(reason))
  end

  defp decode_hello_message(
         <<1, 0, 0::size(72)-integer-unit(8), clientPublicTransientKey::size(32)-binary,
           nonceBinary::size(8)-binary, helloBox::size(80)-binary>>,
         %{curve_secretkey: serverSecretPermanentKey} = curveData
       ) do
    <<nonce::size(8)-integer-unit(8)>> = nonceBinary
    helloNonceBinary = <<"CurveZMQHELLO---", nonceBinary::binary>>

    {:ok, <<0::size(64)-integer-unit(8)>>} =
      :chumak_curve_if.box_open(
        helloBox,
        helloNonceBinary,
        clientPublicTransientKey,
        serverSecretPermanentKey
      )

    newCurveData =
      Map.merge(curveData, %{
        client_nonce: nonce,
        client_public_transient_key: clientPublicTransientKey
      })

    {:ok, erlrecord_hello([]), newCurveData}
  end

  defp decode_welcome_message(
         <<nonceBinary::size(16)-binary, welcomeBox::size(144)-binary>>,
         %{
           client_secret_transient_key: clientSecretTransientKey,
           curve_serverkey: serverPublicPermanentKey
         } = curveData
       ) do
    welcomeNonceBinary = <<"WELCOME-", nonceBinary::binary>>

    {:ok, <<serverPublicTransientKey::size(32)-binary, cookie::size(96)-binary>>} =
      :chumak_curve_if.box_open(
        welcomeBox,
        welcomeNonceBinary,
        serverPublicPermanentKey,
        clientSecretTransientKey
      )

    newCurveData =
      Map.merge(curveData, %{
        server_public_transient_key: serverPublicTransientKey,
        cookie: cookie
      })

    {:ok, erlrecord_welcome([]), newCurveData}
  end

  defp decode_initiate_message(
         <<cookieNonceBinary::size(16)-binary, cookieBox::size(80)-binary,
           nonceBinary::size(8)-binary, initiateBox::binary>>,
         %{
           cookie_public_key: cookiePublicKey,
           cookie_secret_key: cookieSecretKey,
           client_nonce: oldClientNonce
         } = curveData
       ) do
    <<nonce::size(8)-integer-unit(8)>> = nonceBinary
    true = nonce > oldClientNonce
    cookieNonce = <<"COOKIE--", cookieNonceBinary::binary>>

    {:ok,
     <<clientPublicTransientKey::size(32)-binary, serverSecretTransientKey::size(32)-binary>>} =
      :chumak_curve_if.box_open(cookieBox, cookieNonce, cookiePublicKey, cookieSecretKey)

    initiateNonceBinary = <<"CurveZMQINITIATE", nonceBinary::binary>>

    {:ok,
     <<clientPublicPermanentKey::size(32)-binary, vouchNonceBinary::size(16)-binary,
       vouchBox::size(80)-binary,
       metaData::binary>>} =
      :chumak_curve_if.box_open(
        initiateBox,
        initiateNonceBinary,
        clientPublicTransientKey,
        serverSecretTransientKey
      )

    vouchNonce = <<"VOUCH---", vouchNonceBinary::binary>>

    {:ok,
     <<^clientPublicTransientKey::size(32)-binary, _serverPublicPermanentKey::size(32)-binary>>} =
      :chumak_curve_if.box_open(
        vouchBox,
        vouchNonce,
        clientPublicPermanentKey,
        serverSecretTransientKey
      )

    newCurveData =
      Map.merge(curveData, %{
        client_nonce: nonce,
        server_secret_transient_key: serverSecretTransientKey,
        client_public_permanent_key: clientPublicPermanentKey,
        client_public_transient_key: clientPublicTransientKey,
        cookie_secret_key: <<>>,
        cookie_public_key: <<>>
      })

    {:ok,
     erlrecord_initiate(
       metadata: decode_ready_properties(metaData),
       client_public_key: clientPublicPermanentKey
     ), newCurveData}
  end

  defp decode_curve_ready_message(
         <<nonceBinary::size(8)-binary, readyBox::binary>>,
         %{
           server_public_transient_key: serverPublicTransientKey,
           client_secret_transient_key: clientSecretTransientKey
         } = curveData
       ) do
    <<nonce::size(8)-integer-unit(8)>> = nonceBinary
    readyNonceBinary = <<"CurveZMQREADY---", nonceBinary::binary>>

    {:ok, metaData} =
      :chumak_curve_if.box_open(
        readyBox,
        readyNonceBinary,
        serverPublicTransientKey,
        clientSecretTransientKey
      )

    newCurveData = Map.merge(curveData, %{server_nonce: nonce})
    {:ok, erlrecord_ready(metadata: decode_ready_properties(metaData)), newCurveData}
  end

  defp decode_curve_message(
         <<nonceBinary::size(8)-binary, messageBox::binary>>,
         %{
           role: :server,
           client_public_transient_key: publicKey,
           server_secret_transient_key: secretKey,
           client_nonce: oldNonceValue
         } = curveData
       ) do
    <<nonce::size(8)-integer-unit(8)>> = nonceBinary
    true = nonce > oldNonceValue
    messageNonce = <<"CurveZMQMESSAGEC", nonceBinary::binary>>

    {:ok, <<_, messageData::binary>>} =
      :chumak_curve_if.box_open(messageBox, messageNonce, publicKey, secretKey)

    newCurveData = Map.merge(curveData, %{client_nonce: nonce})
    {:ok, messageData, newCurveData}
  end

  defp decode_curve_message(
         <<nonceBinary::size(8)-binary, messageBox::binary>>,
         %{
           role: :client,
           server_public_transient_key: publicKey,
           client_secret_transient_key: secretKey,
           server_nonce: oldNonceValue
         } = curveData
       ) do
    <<nonce::size(8)-integer-unit(8)>> = nonceBinary
    true = nonce > oldNonceValue
    messageNonce = <<"CurveZMQMESSAGES", nonceBinary::binary>>

    {:ok, <<_, messageData::binary>>} =
      :chumak_curve_if.box_open(messageBox, messageNonce, publicKey, secretKey)

    newCurveData = Map.merge(curveData, %{server_nonce: nonce})
    {:ok, messageData, newCurveData}
  end
end
