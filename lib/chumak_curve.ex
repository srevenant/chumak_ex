# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:52

defmodule :chumak_curve do
  # Begin included file: chumak.hrl

  @type transport() :: :tcp

  @type socket_type() ::
          :req | :rep | :dealer | :router | :pub | :xpub | :sub | :xsub | :push | :pull | :pair

  @typep z85_key() :: char_list()

  @typep socket_option() ::
           :curve_server
           | :curve_publickey
           | :curve_secretkey
           | :curve_serverkey
           | :curve_clientkeys

  @typep security_mechanism() :: :null | :curve

  defmacrop erlmacro_SOCKET_OPTS(opts) do
    quote do
      :lists.append([:binary, {:active, false}, {:reuseaddr, true}], unquote(opts))
    end
  end

  defmacrop erlconst_GREETINGS_TIMEOUT() do
    quote do
      1000
    end
  end

  defmacrop erlconst_RECONNECT_TIMEOUT() do
    quote do
      2000
    end
  end

  # End included file: chumak.hrl

  @type curve_data() :: %{
          mechanism: :curve,
          role: :client | :server,
          curve_publickey: binary(),
          curve_secretkey: binary(),
          curve_serverkey: binary(),
          client_nonce: integer(),
          server_nonce: integer(),
          client_public_transient_key: binary(),
          client_secret_transient_key: binary(),
          server_public_transient_key: binary(),
          server_secret_transient_key: binary(),
          cookie_public_key: binary(),
          cookie_secret_key: binary()
        }

  defmacrop erlconst_SMALL_COMMAND() do
    quote do
      4
    end
  end

  defmacrop erlconst_LARGE_COMMAND() do
    quote do
      6
    end
  end

  @spec security_handshake(:gen_tcp.socket(), :chumak_protocol.decoder(), boolean(), term()) ::
          {:chumak_protocol.decoder(), {:ok, :chumak_peer.handshake_data()} | {:error, term()}}

  def security_handshake(socket, decoder, false, metadata) do
    try do
      curveData = :chumak_protocol.decoder_security_data(decoder)
      {:ok, curveData2} = validate_client_curve_data(curveData)
      {:ok, curveData3} = send_hello_step(socket, curveData2)
      decoder2 = :chumak_protocol.set_decoder_security_data(decoder, curveData3)
      {:ok, welcomeFrame} = :gen_tcp.recv(socket, 170, erlconst_GREETINGS_TIMEOUT())
      {:ok, decoder3, [_welcome]} = :chumak_protocol.decode(decoder2, welcomeFrame)
      curveData4 = :chumak_protocol.decoder_security_data(decoder3)
      {:ok, curveData5} = send_initiate_step(socket, curveData4, metadata)
      decoder4 = :chumak_protocol.set_decoder_security_data(decoder, curveData5)
      {:ok, readyFrame} = receive_command(socket)
      {:ok, decoder5, [ready]} = :chumak_protocol.decode(decoder4, readyFrame)
      metaData = :chumak_command.ready_metadata(ready)
      curveData6 = :chumak_protocol.decoder_security_data(decoder5)
      {decoder5, {:ready, Map.merge(metaData, %{security_data: curveData6})}}
    catch
      :error, {:badmatch, error} ->
        :error_logger.error_report([:negotiate_greetings_error, {:error, error}])
        {decoder, {:error, error}}
    end
  end

  def security_handshake(socket, decoder, true, metadata) do
    try do
      curveData = :chumak_protocol.decoder_security_data(decoder)

      {:ok, %{curve_clientkeys: allowedClients} = curveData2} =
        validate_server_curve_data(curveData)

      decoder2 = :chumak_protocol.set_decoder_security_data(decoder, curveData2)
      {:ok, helloFrame} = :gen_tcp.recv(socket, 202, erlconst_GREETINGS_TIMEOUT())
      {:ok, decoder3, [_hello]} = :chumak_protocol.decode(decoder2, helloFrame)
      curveData3 = :chumak_protocol.decoder_security_data(decoder3)
      {:ok, curveData4} = send_welcome_step(socket, curveData3)
      decoder4 = :chumak_protocol.set_decoder_security_data(decoder3, curveData4)
      {:ok, initiateFrame} = receive_command(socket)
      {:ok, decoder5, [initiate]} = :chumak_protocol.decode(decoder4, initiateFrame)

      case(allowedClients) do
        :any ->
          :ok

        _ ->
          clientKey = :chumak_command.initiate_client_key(initiate)
          true = :lists.member(clientKey, allowedClients)
      end

      metaData = :chumak_command.initiate_metadata(initiate)
      curveData5 = :chumak_protocol.decoder_security_data(decoder5)
      {:ok, curveData6} = send_ready_step(socket, curveData5, metadata)
      decoder6 = :chumak_protocol.set_decoder_security_data(decoder5, curveData6)
      {decoder6, {:ready, Map.merge(metaData, %{security_data: curveData6})}}
    catch
      :error, {:badmatch, error} ->
        :error_logger.error_report([:negotiate_greetings_error, {:error, error}])
        {decoder, {:error, error}}
    end
  end

  defp receive_command(socket) do
    case(:gen_tcp.recv(socket, 1, erlconst_GREETINGS_TIMEOUT())) do
      {:ok, <<erlconst_SMALL_COMMAND()>>} ->
        {:ok, <<size>>} = :gen_tcp.recv(socket, 1, erlconst_GREETINGS_TIMEOUT())
        {:ok, frame} = :gen_tcp.recv(socket, size, erlconst_GREETINGS_TIMEOUT())
        {:ok, <<erlconst_SMALL_COMMAND(), size, frame::binary>>}

      {:ok, <<erlconst_LARGE_COMMAND()>>} ->
        {:ok, <<size::64>>} = :gen_tcp.recv(socket, 8, erlconst_GREETINGS_TIMEOUT())
        {:ok, frame} = :gen_tcp.recv(socket, size, erlconst_GREETINGS_TIMEOUT())
        {:ok, <<erlconst_LARGE_COMMAND(), size::64, frame::binary>>}

      {:error, _} = error ->
        error
    end
  end

  defp send_hello_step(socket, curveData) do
    {hello, newCurveData} = :chumak_protocol.build_hello_frame(curveData)

    case(:gen_tcp.send(socket, hello)) do
      :ok ->
        {:ok, newCurveData}

      {:error, sendReason} ->
        {:error, {:send_hello_error, sendReason}}
    end
  end

  defp send_welcome_step(socket, curveData) do
    {welcome, cookie} = :chumak_protocol.build_welcome_frame(curveData)

    case(:gen_tcp.send(socket, welcome)) do
      :ok ->
        {:ok, cookie}

      {:error, sendReason} ->
        {:error, {:send_hello_error, sendReason}}
    end
  end

  defp send_initiate_step(socket, curveData, metadata) do
    {initiate, newCurveData} = :chumak_protocol.build_initiate_frame(metadata, curveData)

    case(:gen_tcp.send(socket, initiate)) do
      :ok ->
        {:ok, newCurveData}

      {:error, sendReason} ->
        {:error, {:send_initiate_error, sendReason}}
    end
  end

  defp send_ready_step(socket, curveData, metadata) do
    {ready, newCurveData} = :chumak_protocol.build_ready_frame(metadata, curveData)

    case(:gen_tcp.send(socket, ready)) do
      :ok ->
        {:ok, newCurveData}

      {:error, sendReason} ->
        {:error, {:send_ready_error, sendReason}}
    end
  end

  defp validate_client_curve_data(curveData) when is_map(curveData) do
    true = is_binary(:maps.get(:curve_serverkey, curveData, :undefined))
    %{public: pK, secret: sK} = :chumak_curve_if.box_keypair()

    {:ok,
     Map.merge(curveData, %{
       mechanism: :curve,
       role: :client,
       client_secret_transient_key: sK,
       client_public_transient_key: pK,
       client_nonce: 1
     })}
  end

  defp validate_server_curve_data(curveData) when is_map(curveData) do
    true = is_binary(:maps.get(:curve_secretkey, curveData, :undefined))
    clientKeys = :maps.get(:curve_clientkeys, curveData, :any)
    %{public: pK, secret: sK} = :chumak_curve_if.box_keypair()
    %{public: cookie_PK, secret: cookie_SK} = :chumak_curve_if.box_keypair()

    {:ok,
     Map.merge(curveData, %{
       mechanism: :curve,
       curve_clientkeys: clientKeys,
       role: :server,
       server_secret_transient_key: sK,
       server_public_transient_key: pK,
       cookie_public_key: cookie_PK,
       cookie_secret_key: cookie_SK,
       server_nonce: 1
     })}
  end
end
