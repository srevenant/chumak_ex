# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:57

defmodule :chumak_rep do
  require Record

  @behaviour :chumak_pattern

  @erlrecordfields_chumak_rep [:identity, :pending_recv, :state, :lb, :last_recv_peer]
  Record.defrecordp(:erlrecord_chumak_rep, :chumak_rep,
    identity: :undefined,
    pending_recv: nil,
    state: :idle,
    lb: :undefined,
    last_recv_peer: nil
  )

  def valid_peer_type(:req) do
    :valid
  end

  def valid_peer_type(:dealer) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    state = erlrecord_chumak_rep(identity: var_identity, lb: :chumak_lb.new())
    {:ok, state}
  end

  def terminate(_reason, _state) do
    :ok
  end

  def identity(erlrecord_chumak_rep(identity: i)) do
    i
  end

  def peer_flags(_state) do
    {:rep, [:incoming_queue]}
  end

  def accept_peer(state, peerPid) do
    newLb = :chumak_lb.put(erlrecord_chumak_rep(state, :lb), peerPid)
    {:reply, {:ok, peerPid}, erlrecord_chumak_rep(state, lb: newLb)}
  end

  def peer_ready(state, _peerPid, _identity) do
    {:noreply, state}
  end

  def send(erlrecord_chumak_rep(last_recv_peer: nil) = state, _data, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def send(erlrecord_chumak_rep(last_recv_peer: lastRecvPeer) = state, data, _from)
      when is_pid(lastRecvPeer) do
    :chumak_peer.send(lastRecvPeer, [<<>>, data])
    {:reply, :ok, erlrecord_chumak_rep(state, last_recv_peer: nil)}
  end

  def recv(erlrecord_chumak_rep(state: :idle, lb: lB) = state, from) do
    case(:chumak_lb.get(lB)) do
      :none ->
        {:noreply, erlrecord_chumak_rep(state, state: :wait_req, pending_recv: {:from, from})}

      {newLB, peerPid} ->
        direct_recv(erlrecord_chumak_rep(state, lb: newLB), peerPid, peerPid, from)
    end
  end

  def recv(state, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def unblock(erlrecord_chumak_rep(pending_recv: {:from, pendingRecv}) = state, _from) do
    newState = erlrecord_chumak_rep(state, pending_recv: nil)
    :gen_server.reply(pendingRecv, {:error, :again})
    {:reply, :ok, newState}
  end

  def unblock(erlrecord_chumak_rep(pending_recv: nil) = state, _from) do
    {:reply, :ok, state}
  end

  def send_multipart(state, _multipart, _from) do
    {:reply, {:error, :not_implemented_yet}, state}
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :not_implemented_yet}, state}
  end

  def peer_recv_message(state, _message, _from) do
    {:noreply, state}
  end

  def queue_ready(
        erlrecord_chumak_rep(state: :wait_req, pending_recv: {:from, pendingRecv}) = state,
        _identity,
        peerPid
      ) do
    futureState = erlrecord_chumak_rep(state, state: :idle, pending_recv: nil)

    case(recv_from_peer(peerPid)) do
      {:ok, message} ->
        :gen_server.reply(pendingRecv, {:ok, message})
        {:noreply, erlrecord_chumak_rep(futureState, last_recv_peer: peerPid)}

      {:error, reason} ->
        :gen_server.reply(pendingRecv, {:error, reason})
        {:noreply, futureState}

      :empty ->
        :gen_server.reply(pendingRecv, {:error, :queue_empty})
        {:noreply, futureState}
    end
  end

  def queue_ready(state, _identity, _peerPid) do
    {:noreply, state}
  end

  def peer_disconected(erlrecord_chumak_rep(lb: lB) = state, peerPid) do
    newLB = :chumak_lb.delete(lB, peerPid)
    {:noreply, erlrecord_chumak_rep(state, lb: newLB)}
  end

  defp direct_recv(erlrecord_chumak_rep(lb: lB) = state, firstPeerPid, peerPid, from) do
    case(recv_from_peer(peerPid)) do
      {:ok, message} ->
        {:reply, {:ok, message}, erlrecord_chumak_rep(state, last_recv_peer: peerPid)}

      {:error, reason} ->
        {:reply, {:error, reason}, state}

      :empty ->
        case(:chumak_lb.get(lB)) do
          {newLB, ^firstPeerPid} ->
            {:noreply,
             erlrecord_chumak_rep(state, state: :wait_req, pending_recv: {:from, from}, lb: newLB)}

          {newLB, otherPeerPid} ->
            direct_recv(erlrecord_chumak_rep(state, lb: newLB), firstPeerPid, otherPeerPid, from)
        end
    end
  end

  defp recv_from_peer(peerPid) do
    case(:chumak_peer.incoming_queue_out(peerPid)) do
      {:out, messages} ->
        decode_messages(messages)

      :empty ->
        :empty

      {:error, info} ->
        :error_logger.info_msg('can\'t get message out in ~p with reason: ~p~n', [
          :chumak_rep,
          info
        ])

        :empty
    end
  end

  defp decode_messages([<<>> | tail]) do
    {:ok, :binary.list_to_bin(tail)}
  end

  defp decode_messages([delimiter | _tail]) do
    :error_logger.warning_report(
      {:invalid_delimiter_frame, {:pattern, :rep}, {:obtained_frame, delimiter},
       {:expected_frame, <<>>}}
    )

    {:error, :invalid_delimiter_frame}
  end
end
