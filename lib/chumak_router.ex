# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:58

defmodule :chumak_router do
  require Record

  @behaviour :chumak_pattern

  @erlrecordfields_chumak_router [:identity, :lbs, :pending_recv, :recv_queue]
  Record.defrecordp(:erlrecord_chumak_router, :chumak_router,
    identity: :undefined,
    lbs: :undefined,
    pending_recv: :undefined,
    recv_queue: :undefined
  )

  def valid_peer_type(:req) do
    :valid
  end

  def valid_peer_type(:router) do
    :valid
  end

  def valid_peer_type(:dealer) do
    :valid
  end

  def valid_peer_type(_) do
    :invalid
  end

  def init(var_identity) do
    state =
      erlrecord_chumak_router(
        identity: var_identity,
        lbs: :chumak_lbs.new(),
        recv_queue: :queue.new(),
        pending_recv: nil
      )

    {:ok, state}
  end

  def terminate(_reason, erlrecord_chumak_router(pending_recv: var_recv)) do
    case(var_recv) do
      {:from, from} ->
        :gen_server.reply(from, {:error, :closed})

      _ ->
        :ok
    end

    :ok
  end

  def identity(erlrecord_chumak_router(identity: i)) do
    i
  end

  def peer_flags(_state) do
    {:router, [:incoming_queue]}
  end

  def accept_peer(state, peerPid) do
    {:reply, {:ok, peerPid}, state}
  end

  def peer_ready(erlrecord_chumak_router(lbs: lBs) = state, peerPid, var_identity) do
    newLBs = :chumak_lbs.put(lBs, var_identity, peerPid)
    {:noreply, erlrecord_chumak_router(state, lbs: newLBs)}
  end

  def send(state, _data, _from) do
    {:reply, {:error, :send_implemented_yet}, state}
  end

  def recv(state, _from) do
    {:reply, {:error, :recv_implemented_yet}, state}
  end

  def send_multipart(erlrecord_chumak_router(lbs: lBs) = state, multipart, _from)
      when length(multipart) >= 2 do
    [var_identity | remmaingMultipart] = multipart

    case(:chumak_lbs.get(lBs, :erlang.binary_to_list(var_identity))) do
      {newLBs, peerPid} ->
        :chumak_peer.send(peerPid, remmaingMultipart)
        {:reply, :ok, erlrecord_chumak_router(state, lbs: newLBs)}

      :none ->
        {:reply, {:error, :no_peers}, state}
    end
  end

  def send_multipart(state, _multipart, _from) do
    {:reply, {:error, :identity_missing}, state}
  end

  def recv_multipart(
        erlrecord_chumak_router(recv_queue: recvQueue, pending_recv: nil) = state,
        from
      ) do
    case(:queue.out(recvQueue)) do
      {{:value, multipart}, newRecvQueue} ->
        {:reply, {:ok, multipart}, erlrecord_chumak_router(state, recv_queue: newRecvQueue)}

      {:empty, _recvQueue} ->
        {:noreply, erlrecord_chumak_router(state, pending_recv: {:from, from})}
    end
  end

  def recv_multipart(state, _from) do
    {:reply, {:error, :efsm}, state}
  end

  def unblock(erlrecord_chumak_router(pending_recv: {:from, pendingRecv}) = state, _from) do
    newState = erlrecord_chumak_router(state, pending_recv: nil)
    :gen_server.reply(pendingRecv, {:error, :again})
    {:reply, :ok, newState}
  end

  def unblock(erlrecord_chumak_router(pending_recv: nil) = state, _from) do
    {:reply, :ok, state}
  end

  def peer_recv_message(state, _message, _from) do
    {:noreply, state}
  end

  def queue_ready(state, var_identity, peerPid) do
    case(:chumak_peer.incoming_queue_out(peerPid)) do
      {:out, multipart} ->
        identityBin = :erlang.list_to_binary(var_identity)
        {:noreply, handle_queue_ready(state, [identityBin | multipart])}

      :empty ->
        {:noreply, state}

      {:error, info} ->
        :error_logger.info_msg('can\'t get message out in ~p with reason: ~p~n', [
          :chumak_router,
          info
        ])

        {:noreply, state}
    end
  end

  def peer_disconected(erlrecord_chumak_router(lbs: lBs) = state, peerPid) do
    newLBs = :chumak_lbs.delete(lBs, peerPid)
    {:noreply, erlrecord_chumak_router(state, lbs: newLBs)}
  end

  defp handle_queue_ready(
         erlrecord_chumak_router(recv_queue: recvQueue, pending_recv: nil) = state,
         data
       ) do
    newRecvQueue = :queue.in(data, recvQueue)
    erlrecord_chumak_router(state, recv_queue: newRecvQueue)
  end

  defp handle_queue_ready(
         erlrecord_chumak_router(pending_recv: {:from, pendingRecv}) = state,
         data
       ) do
    :gen_server.reply(pendingRecv, {:ok, data})
    erlrecord_chumak_router(state, pending_recv: nil)
  end
end
