# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:55

defmodule :chumak_protocol do
  require Record

  # Begin included file: chumak.hrl

  @type transport() :: :tcp

  @type socket_type() ::
          :req | :rep | :dealer | :router | :pub | :xpub | :sub | :xsub | :push | :pull | :pair

  @typep z85_key() :: char_list()

  @typep socket_option() ::
           :curve_server
           | :curve_publickey
           | :curve_secretkey
           | :curve_serverkey
           | :curve_clientkeys

  @typep security_mechanism() :: :null | :curve

  defmacrop erlmacro_SOCKET_OPTS(opts) do
    quote do
      :lists.append([:binary, {:active, false}, {:reuseaddr, true}], unquote(opts))
    end
  end

  defmacrop erlconst_GREETINGS_TIMEOUT() do
    quote do
      1000
    end
  end

  defmacrop erlconst_RECONNECT_TIMEOUT() do
    quote do
      2000
    end
  end

  # End included file: chumak.hrl

  defmacrop erlconst_PROTOCOL_MAJOR() do
    quote do
      3
    end
  end

  defmacrop erlconst_PROTOCOL_MINOR() do
    quote do
      1
    end
  end

  defmacrop erlconst_SIGNATURE_SIZE() do
    quote do
      11
    end
  end

  defmacrop erlconst_SMALL_LAST_MESSAGE() do
    quote do
      0
    end
  end

  defmacrop erlconst_SMALL_MORE_MESSAGE() do
    quote do
      1
    end
  end

  defmacrop erlconst_LARGE_LAST_MESSAGE() do
    quote do
      2
    end
  end

  defmacrop erlconst_LARGE_MORE_MESSAGE() do
    quote do
      3
    end
  end

  defmacrop erlconst_SMALL_COMMAND() do
    quote do
      4
    end
  end

  defmacrop erlconst_LARGE_COMMAND() do
    quote do
      6
    end
  end

  @erlrecordfields_decoder [
    :state,
    :size,
    :buffer,
    :next_state,
    :version_major,
    :version_minor,
    :security_data,
    :mechanism,
    :as_server
  ]
  Record.defrecordp(:erlrecord_decoder, :decoder,
    state: :initial,
    size: 0,
    buffer: nil,
    next_state: nil,
    version_major: nil,
    version_minor: nil,
    security_data: nil,
    mechanism: nil,
    as_server: false
  )

  @erlrecordfields_message [:frame, :has_more]
  Record.defrecordp(:erlrecord_message, :message, frame: :undefined, has_more: :undefined)

  @typep message() ::
           record(:erlrecord_message,
             frame: :undefined | binary(),
             has_more: :undefined | true | false
           )

  @type decoder() ::
          record(:erlrecord_decoder,
            state: decoder_state(),
            size: integer(),
            buffer: nil | binary(),
            next_state: nil | decoder_state(),
            version_major: nil | {:some, integer()},
            version_minor: nil | {:some, integer()},
            security_data: decoder_security_data(),
            mechanism: nil | security_mechanism(),
            as_server: boolean()
          )

  @typep decoder_state() ::
           :initial
           | :waiting_minor_version
           | :waiting_mechanism
           | :waiting_as_server
           | :waiting_filler
           | :ready
           | :command_ready
           | :message_ready
           | :require_size

  @typep decoder_version() :: {integer(), integer()}

  @typep decoder_security_data() :: %{} | :chumak_curve.curve_data()

  @typep frame() :: binary()

  @typep invalid_version() :: {:invalid_version, atom()}

  @typep invalid_mechanism() :: {:mechanism_not_supported_yet, atom()}

  @typep bad_greeting_frame() :: {:bad_greeting_frame, binary()}

  @typep decode_reason() :: bad_greeting_frame() | invalid_version() | invalid_mechanism()

  @typep decoder_ready() :: {:ready, decoder()}

  @typep decoder_ok() :: {:ok, decoder()}

  @typep decoder_cmds() :: {:ok, decoder(), list(term())}

  @typep decoder_error() :: {:error, decode_reason()}

  @typep decoder_reply() :: decoder_ready() | decoder_ok() | decoder_cmds() | decoder_error()

  @spec build_greeting_frame(boolean(), :chumak.security_mechanism()) :: frame()

  def build_greeting_frame(asServer, mechanism) do
    padding = <<0::64>>
    signature = <<255, padding::binary, 127>>
    mechanismBinary = encode_mechanism(mechanism)

    asServerBinary =
      case(asServer) do
        false ->
          <<0>>

        true ->
          <<1>>
      end

    filler = :binary.copy(<<0>>, 31)

    <<signature::binary, erlconst_PROTOCOL_MAJOR(), erlconst_PROTOCOL_MINOR(),
      mechanismBinary::binary, asServerBinary::binary, filler::binary>>
  end

  def build_hello_frame(
        %{
          client_public_transient_key: clientPublicTransientKey,
          client_secret_transient_key: clientSecretTransientKey,
          curve_serverkey: serverPermanentKey,
          client_nonce: clientShortNonce
        } = securityData
      ) do
    commandName = "HELLO"
    commandNameSize = <<5>>
    version = <<1, 0>>
    padding = <<0::size(72)-integer-unit(8)>>
    clientShortNonceBinary = <<clientShortNonce::size(8)-integer-unit(8)>>
    nonce = <<"CurveZMQHELLO---", clientShortNonceBinary::binary>>

    signatureBox =
      :chumak_curve_if.box(
        <<0::size(64)-integer-unit(8)>>,
        nonce,
        serverPermanentKey,
        clientSecretTransientKey
      )

    command =
      <<commandNameSize::binary, commandName::binary, version::binary, padding::binary,
        clientPublicTransientKey::binary, clientShortNonceBinary::binary, signatureBox::binary>>

    {encode_command(command), Map.merge(securityData, %{client_nonce: clientShortNonce + 1})}
  end

  def build_welcome_frame(
        %{
          server_public_transient_key: serverPublicTransientKey,
          server_secret_transient_key: serverSecretTransientKey,
          curve_secretkey: serverSecretPermanentKey,
          client_public_transient_key: clientPublicTransientKey,
          cookie_public_key: cookiePublicKey,
          cookie_secret_key: cookieSecretKey
        } = curveData
      ) do
    longNonce = :chumak_curve_if.randombytes(16)
    welcomeBoxNonce = <<"WELCOME-", longNonce::binary>>
    cookieBoxNonce = <<"COOKIE--", longNonce::binary>>

    cookieBox =
      :chumak_curve_if.box(
        <<clientPublicTransientKey::binary, serverSecretTransientKey::binary>>,
        cookieBoxNonce,
        cookiePublicKey,
        cookieSecretKey
      )

    cookie = <<longNonce::binary, cookieBox::binary>>

    welcomeBox =
      :chumak_curve_if.box(
        <<serverPublicTransientKey::binary, cookie::binary>>,
        welcomeBoxNonce,
        clientPublicTransientKey,
        serverSecretPermanentKey
      )

    welcome = <<7, "WELCOME"::binary, longNonce::binary, welcomeBox::binary>>

    newCD =
      Map.merge(curveData, %{
        server_public_transient_key: <<>>,
        server_secret_transient_key: <<>>,
        client_public_transient_key: <<>>
      })

    {encode_command(welcome), newCD}
  end

  def build_initiate_frame(
        metaData,
        %{
          client_nonce: clientShortNonce,
          client_public_transient_key: clientPublicTransientKey,
          client_secret_transient_key: clientSecretTransientKey,
          curve_publickey: clientPublicPermanentKey,
          curve_secretkey: clientSecretPermanentKey,
          server_public_transient_key: serverPublicTransientKey,
          curve_serverkey: serverPublicPermanentKey,
          cookie: cookie
        } = curveData
      ) do
    clientShortNonceBinary = <<clientShortNonce::size(8)-integer-unit(8)>>
    longNonce = :chumak_curve_if.randombytes(16)
    vouchBoxNonce = <<"VOUCH---", longNonce::binary>>
    initiateBoxNonce = <<"CurveZMQINITIATE", clientShortNonceBinary::binary>>

    vouchBox =
      :chumak_curve_if.box(
        <<clientPublicTransientKey::binary, serverPublicPermanentKey::binary>>,
        vouchBoxNonce,
        serverPublicTransientKey,
        clientSecretPermanentKey
      )

    vouch = <<longNonce::binary, vouchBox::binary>>
    metaDataBinary = :chumak_command.encode_ready_properties(metaData)

    initiateBox =
      :chumak_curve_if.box(
        <<clientPublicPermanentKey::binary, vouch::binary, metaDataBinary::binary>>,
        initiateBoxNonce,
        serverPublicTransientKey,
        clientSecretTransientKey
      )

    initiate =
      <<8, "INITIATE"::binary, cookie::binary, clientShortNonceBinary::binary,
        initiateBox::binary>>

    {encode_command(initiate), Map.merge(curveData, %{client_nonce: clientShortNonce + 1})}
  end

  def build_ready_frame(
        metaData,
        %{
          client_public_transient_key: clientPublicTransientKey,
          server_secret_transient_key: serverSecretTransientKey,
          server_nonce: serverShortNonce
        } = curveData
      ) do
    serverShortNonceBinary = <<serverShortNonce::size(8)-integer-unit(8)>>
    readyBoxNonce = <<"CurveZMQREADY---", serverShortNonceBinary::binary>>
    metaDataBinary = :chumak_command.encode_ready_properties(metaData)

    readyBox =
      :chumak_curve_if.box(
        <<metaDataBinary::binary>>,
        readyBoxNonce,
        clientPublicTransientKey,
        serverSecretTransientKey
      )

    ready = <<5, "READY", serverShortNonceBinary::binary, readyBox::binary>>
    {encode_command(ready), Map.merge(curveData, %{server_nonce: serverShortNonce + 1})}
  end

  defp build_message(
         message,
         :curve,
         %{
           role: :client,
           client_secret_transient_key: secretKey,
           server_public_transient_key: publicKey,
           client_nonce: clientNonce
         } = securityData
       ) do
    nonceBinary = <<clientNonce::size(8)-integer-unit(8)>>
    nonce = <<"CurveZMQMESSAGEC", nonceBinary::binary>>
    messageBox = :chumak_curve_if.box(<<0, message::binary>>, nonce, publicKey, secretKey)

    {<<7, "MESSAGE", nonceBinary::binary, messageBox::binary>>,
     Map.merge(securityData, %{client_nonce: clientNonce + 1})}
  end

  defp build_message(
         message,
         :curve,
         %{
           role: :server,
           server_secret_transient_key: secretKey,
           client_public_transient_key: publicKey,
           server_nonce: serverNonce
         } = securityData
       ) do
    nonceBinary = <<serverNonce::size(8)-integer-unit(8)>>
    nonce = <<"CurveZMQMESSAGES", nonceBinary::binary>>
    messageBox = :chumak_curve_if.box(<<0, message::binary>>, nonce, publicKey, secretKey)

    {<<7, "MESSAGE", nonceBinary::binary, messageBox::binary>>,
     Map.merge(securityData, %{server_nonce: serverNonce + 1})}
  end

  defp build_message(message, _, securityData) do
    {message, securityData}
  end

  @spec new_decoder(decoder_security_data()) :: decoder()

  def new_decoder(securityData) do
    erlrecord_decoder(security_data: securityData)
  end

  @spec decode(decoder(), frame()) :: decoder_reply()

  def decode(erlrecord_decoder(state: :ready) = decoder, frame) do
    <<flag::size(1)-binary, _::binary>> = frame

    nextState =
      case(flag) do
        <<_::5, 1::1, _::1, _::1>> ->
          :command_ready

        <<_::5, 0::1, _::1, _::1>> ->
          :message_ready
      end

    case(frame) do
      <<_::5, _::1, 0::1, _::1, size, _remaingFrame::binary>> ->
        require_size(decoder, size + 2, frame, nextState)

      <<_::5, _::1, 1::1, _::1, size::64, _remaingFrame::binary>> ->
        require_size(decoder, size + 9, frame, nextState)

      <<_::5, _::1, 0::1, _::1>> ->
        require_size(decoder, 2, frame, :ready)

      <<_::5, _::1, 1::1, _::1, _tooShortToBeSize::binary>> ->
        require_size(decoder, 9, frame, :ready)

      x ->
        {:error, {:bad_ready_packet, x}}
    end
  end

  def decode(erlrecord_decoder(state: :command_ready) = decoder, frame) do
    case(frame) do
      <<erlconst_SMALL_COMMAND(), commandSize, remaingFrame::binary>> ->
        decode_command(decoder, commandSize, remaingFrame)

      <<erlconst_LARGE_COMMAND(), commandSize::64, remaingFrame::binary>> ->
        decode_command(decoder, commandSize, remaingFrame)

      x ->
        {:error, {:bad_command_packet, x}}
    end
  end

  def decode(erlrecord_decoder(state: :message_ready) = decoder, frame) do
    case(frame) do
      <<_::5, _::1, 0::1, more::1, size, remaingFrame::binary>> ->
        decode_message(decoder, size, remaingFrame, more)

      <<_::5, _::1, 1::1, more::1, size::64, remaingFrame::binary>> ->
        decode_message(decoder, size, remaingFrame, more)

      x ->
        {:error, {:bad_message_packet, x}}
    end
  end

  def decode(erlrecord_decoder(state: :require_size) = decoder, frame) do
    currentBuffer = erlrecord_decoder(decoder, :buffer)

    require_size(
      decoder,
      erlrecord_decoder(decoder, :size),
      <<currentBuffer::binary, frame::binary>>,
      erlrecord_decoder(decoder, :next_state)
    )
  end

  def decode(erlrecord_decoder(state: :initial) = decoder, frame)
      when byte_size(frame) >= erlconst_SIGNATURE_SIZE() do
    case(frame) do
      <<255, _padding::size(64)-bitstring, 127, versionMajor, remaingFrame::binary>>
      when versionMajor >= erlconst_PROTOCOL_MAJOR() ->
        continue_decode(
          erlrecord_decoder(decoder,
            state: :waiting_minor_version,
            version_major: {:some, versionMajor}
          ),
          remaingFrame
        )

      <<255, _padding::size(64)-bitstring, 127, versionMajor, _remaingFrame::binary>> ->
        {:error, {:invalid_version, versionMajor}}

      x ->
        {:error, {:bad_greeting_frame, x}}
    end
  end

  def decode(erlrecord_decoder(state: :initial) = decoder, frame) do
    require_size(decoder, erlconst_SIGNATURE_SIZE(), frame, :initial)
  end

  def decode(erlrecord_decoder(state: :waiting_minor_version) = decoder, frame) do
    case(frame) do
      <<versionMinor, remaingFrame::binary>> ->
        continue_decode(
          erlrecord_decoder(decoder,
            state: :waiting_mechanism,
            version_minor: {:some, versionMinor}
          ),
          remaingFrame
        )

      x ->
        {:error, {:bad_greeting_frame, x}}
    end
  end

  def decode(erlrecord_decoder(state: :waiting_mechanism) = decoder, frame) do
    case(frame) do
      <<mechanism::size(160)-bitstring, remaingFrame::binary>> ->
        case(strip_binary_to_atom(mechanism)) do
          :NULL ->
            continue_decode(
              erlrecord_decoder(decoder, state: :waiting_as_server, mechanism: :null),
              remaingFrame
            )

          :PLAIN ->
            {:error, {:mechanism_not_supported_yet, :PLAIN}}

          :CURVE ->
            continue_decode(
              erlrecord_decoder(decoder, state: :waiting_as_server, mechanism: :curve),
              remaingFrame
            )

          mechanismType ->
            {:error, {:invalid_mechanism, mechanismType}}
        end

      x ->
        {:error, {:bad_greeting_frame, x}}
    end
  end

  def decode(erlrecord_decoder(state: :waiting_as_server) = decoder, frame) do
    case(frame) do
      <<asServer, remaingFrame::binary>> ->
        asServerBool =
          case(asServer) do
            1 ->
              true

            0 ->
              false
          end

        continue_decode(
          erlrecord_decoder(decoder, state: :waiting_filler, as_server: asServerBool),
          remaingFrame
        )
    end
  end

  def decode(erlrecord_decoder(state: :waiting_filler) = decoder, frame) do
    case(frame) do
      <<0::248, remaingFrame::binary>> ->
        {:ready, erlrecord_decoder(decoder, state: :ready, buffer: remaingFrame)}
    end
  end

  @spec continue_decode(decoder()) :: decoder_reply()

  def continue_decode(erlrecord_decoder(buffer: buffer) = decoder) when is_binary(buffer) do
    continue_decode(erlrecord_decoder(decoder, buffer: nil), buffer)
  end

  @spec decoder_state(decoder()) :: decoder_state()

  def decoder_state(erlrecord_decoder(state: state)) do
    state
  end

  @spec decoder_version(decoder()) :: decoder_version()

  def decoder_version(
        erlrecord_decoder(
          version_major: {:some, versionMajor},
          version_minor: {:some, versionMinor}
        )
      ) do
    {versionMajor, versionMinor}
  end

  @spec decoder_mechanism(decoder()) :: security_mechanism()

  def decoder_mechanism(erlrecord_decoder(mechanism: mechanism)) do
    mechanism
  end

  @spec decoder_as_server(decoder()) :: boolean()

  def decoder_as_server(erlrecord_decoder(as_server: asServer)) do
    asServer
  end

  @spec decoder_buffer(decoder()) :: binary() | nil

  def decoder_buffer(erlrecord_decoder(buffer: buffer)) do
    buffer
  end

  @spec decoder_security_data(decoder()) :: nil | :chumak_curve.curve_data()

  def decoder_security_data(erlrecord_decoder(security_data: securityData)) do
    securityData
  end

  @spec set_decoder_security_data(decoder(), decoder_security_data()) :: decoder()

  def set_decoder_security_data(decoder, securityData) do
    erlrecord_decoder(decoder, security_data: securityData)
  end

  @spec encode_command(binary()) :: binary()

  def encode_command(command) when is_binary(command) do
    encode_frame(erlconst_SMALL_COMMAND(), erlconst_LARGE_COMMAND(), command)
  end

  @spec encode_old_subscribe(binary()) :: binary()

  def encode_old_subscribe(topic) do
    {encoded, _} = encode_last_message(<<1, topic::binary>>, :null, %{})
    encoded
  end

  @spec encode_old_cancel(binary()) :: binary()

  def encode_old_cancel(topic) do
    {encoded, _} = encode_last_message(<<0, topic::binary>>, :null, %{})
    encoded
  end

  @spec encode_message_multipart(list(binary()), security_mechanism(), map()) :: {binary(), map()}

  def encode_message_multipart(multipart, mechanism, securityData) do
    more = :lists.sublist(multipart, length(multipart) - 1)
    last = :lists.last(multipart)

    {moreTrafficList, newSecurityData} =
      :lists.mapfoldl(
        fn part, sDataAcc -> encode_more_message(part, mechanism, sDataAcc) end,
        securityData,
        more
      )

    moreTraffic = :binary.list_to_bin(moreTrafficList)
    {lastTraffic, finalSecData} = encode_last_message(last, mechanism, newSecurityData)
    {<<moreTraffic::binary, lastTraffic::binary>>, finalSecData}
  end

  @spec encode_more_message(binary(), security_mechanism(), map()) :: {binary(), map()}

  def encode_more_message(message, mechanism, securityData) when is_binary(message) do
    {frame, newSecurityData} = build_message(message, mechanism, securityData)

    {encode_frame(erlconst_SMALL_MORE_MESSAGE(), erlconst_LARGE_MORE_MESSAGE(), frame),
     newSecurityData}
  end

  @spec encode_last_message(binary(), security_mechanism(), map()) :: {binary(), map()}

  def encode_last_message(message, mechanism, securityData) when is_binary(message) do
    {frame, newSecurityData} = build_message(message, mechanism, securityData)

    {encode_frame(erlconst_SMALL_LAST_MESSAGE(), erlconst_LARGE_LAST_MESSAGE(), frame),
     newSecurityData}
  end

  @spec message_data(message()) :: binary()

  def message_data(erlrecord_message(frame: data)) do
    data
  end

  @spec message_has_more(message()) :: true | false

  def message_has_more(erlrecord_message(has_more: hasMore)) do
    hasMore
  end

  defp continue_decode(decoder, <<>>) do
    {:ok, decoder}
  end

  defp continue_decode(decoder, frame) do
    decode(decoder, frame)
  end

  defp decode_command(erlrecord_decoder(security_data: securityData) = decoder, size, frame) do
    <<commandFrame::size(size)-binary, remaingFrame::binary>> = frame

    case(:chumak_command.decode(commandFrame, securityData)) do
      {:ok, command, newSecurityData} ->
        accumule_commands(
          erlrecord_decoder(decoder, security_data: newSecurityData),
          command,
          remaingFrame
        )

      {:error, _} = error ->
        error
    end
  end

  defp decode_message(
         erlrecord_decoder(security_data: securityData) = decoder,
         size,
         frame,
         moreFlag
       ) do
    hasMore =
      case(moreFlag) do
        1 ->
          true

        0 ->
          false
      end

    <<messageFrame::size(size)-binary, remaingFrame::binary>> = frame
    {decodedFrame, newSecurityData} = decode_frame(messageFrame, securityData)

    accumule_commands(
      erlrecord_decoder(decoder, security_data: newSecurityData),
      erlrecord_message(frame: decodedFrame, has_more: hasMore),
      remaingFrame
    )
  end

  defp decode_frame(curveMessage, %{mechanism: :curve} = securityData) do
    case(:chumak_command.decode(curveMessage, securityData)) do
      {:ok, message, newSecurityData} ->
        {message, newSecurityData}
    end
  end

  defp decode_frame(frame, securityData) do
    {frame, securityData}
  end

  defp accumule_commands(decoder, command, frame) do
    readyDecoder = erlrecord_decoder(decoder, state: :ready)

    case(continue_decode(readyDecoder, frame)) do
      {:ok, updatedDecoder} ->
        {:ok, updatedDecoder, [command]}

      {:ok, updatedDecoder, commands} ->
        {:ok, updatedDecoder, [command | commands]}

      error ->
        error
    end
  end

  defp require_size(decoder, size, frame, nextState) when byte_size(frame) >= size do
    decode(erlrecord_decoder(decoder, state: nextState, buffer: nil), frame)
  end

  defp require_size(decoder, size, frame, nextState) do
    {:ok,
     erlrecord_decoder(decoder,
       state: :require_size,
       size: size,
       buffer: frame,
       next_state: nextState
     )}
  end

  defp strip_binary_to_atom(bin) do
    [t, _] = :binary.split(bin, <<0>>)
    :erlang.binary_to_atom(t, :utf8)
  end

  defp encode_frame(smallFlag, _largeFlag, frame) when byte_size(frame) < 256 do
    size = byte_size(frame)
    <<smallFlag, size, frame::binary>>
  end

  defp encode_frame(_smallFlag, largeFlag, frame) do
    size = byte_size(frame)
    sizeFrame = :binary.encode_unsigned(size)
    padding = :binary.copy(<<0>>, 8 - byte_size(sizeFrame))
    <<largeFlag, padding::binary, sizeFrame::binary, frame::binary>>
  end

  defp encode_mechanism(:null) do
    <<"NULL"::binary, 0::128>>
  end

  defp encode_mechanism(:curve) do
    <<"CURVE"::binary, 0::120>>
  end
end
