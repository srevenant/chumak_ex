# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-05-02 12:33:54

defmodule :chumak_pattern do
  # Begin included file: chumak.hrl

  @type transport() :: :tcp

  @type socket_type() ::
          :req | :rep | :dealer | :router | :pub | :xpub | :sub | :xsub | :push | :pull | :pair

  @typep z85_key() :: char_list()

  @typep socket_option() ::
           :curve_server
           | :curve_publickey
           | :curve_secretkey
           | :curve_serverkey
           | :curve_clientkeys

  @typep security_mechanism() :: :null | :curve

  defmacrop erlmacro_SOCKET_OPTS(opts) do
    quote do
      :lists.append([:binary, {:active, false}, {:reuseaddr, true}], unquote(opts))
    end
  end

  defmacrop erlconst_GREETINGS_TIMEOUT() do
    quote do
      1000
    end
  end

  defmacrop erlconst_RECONNECT_TIMEOUT() do
    quote do
      2000
    end
  end

  # End included file: chumak.hrl

  @typep pattern_state() :: tuple()

  @callback valid_peer_type(socket_type()) :: :valid | :invalid

  @callback init(char_list()) :: {:ok, pattern_state()}

  @callback terminate(term(), pattern_state()) :: :ok

  @callback peer_flags(pattern_state()) :: {socket_type(), list(term())}

  @callback accept_peer(pattern_state(), pid()) :: term()

  @callback peer_ready(pattern_state(), pid(), binary()) :: term()

  @callback send(pattern_state(), binary(), term()) :: term()

  @callback recv(pattern_state(), term()) :: term()

  @callback identity(pattern_state()) :: char_list()

  @callback send_multipart(pattern_state(), list(binary()), term()) :: term()

  @callback recv_multipart(pattern_state(), term()) :: term()

  @callback peer_recv_message(pattern_state(), :chumak_protocol.message(), pid()) :: term()

  @callback queue_ready(pattern_state(), char_list(), pid()) :: term()

  @callback peer_disconected(pattern_state(), pid()) :: term()

  @callback unblock(pattern_state(), term()) :: term()

  @spec module(socket_type()) :: module() | {:error, :invalid_socket_type}

  def module(:req) do
    :chumak_req
  end

  def module(:rep) do
    :chumak_rep
  end

  def module(:dealer) do
    :chumak_dealer
  end

  def module(:router) do
    :chumak_router
  end

  def module(:pub) do
    :chumak_pub
  end

  def module(:sub) do
    :chumak_sub
  end

  def module(:xpub) do
    :chumak_xpub
  end

  def module(:xsub) do
    :chumak_xsub
  end

  def module(:push) do
    :chumak_push
  end

  def module(:pull) do
    :chumak_pull
  end

  def module(:pair) do
    :chumak_pair
  end

  def module(_) do
    {:error, :invalid_socket_type}
  end

  def error_msg(:efsm) do
    'operation cannot be performed on this socket at the moment'
  end
end
